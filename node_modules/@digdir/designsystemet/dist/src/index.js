// src/colors/colorMetadata.ts
import * as R from "ramda";
var baseColors = {
  info: "#0A71C0",
  success: "#068718",
  warning: "#EA9B1B",
  danger: "#C01B1B"
};
var dsLinkColor = "#663299";
var colorMetadata = {
  "background-default": {
    number: 1,
    name: "background-default",
    group: "background",
    displayName: "Background Default",
    description: {
      long: "Background Default er den mest n\xF8ytrale bakgrunnsfargen.",
      short: "Standard bakgrunnsfarge."
    },
    luminance: {
      light: 1,
      dark: 9e-3,
      contrast: 1e-3
    }
  },
  "background-tinted": {
    number: 2,
    name: "background-tinted",
    group: "background",
    displayName: "Background Tinted",
    description: {
      long: "Background Tinted er en bakgrunnsfarge som har et hint av farge i seg.",
      short: "Bakgrunn med et hint av farge i seg."
    },
    luminance: {
      light: 0.9,
      dark: 0.014,
      contrast: 65e-4
    }
  },
  "surface-default": {
    number: 3,
    name: "surface-default",
    group: "surface",
    displayName: "Surface Default",
    description: {
      long: "Surface Default brukes p\xE5 flater som ligger opp\xE5 bakgrunnsfargene. Dette er den mest n\xF8ytrale surface fargen.",
      short: "Standardfarge for overflater / komponenter."
    },
    luminance: {
      light: 1,
      dark: 0.021,
      contrast: 0.015
    }
  },
  "surface-tinted": {
    number: 4,
    name: "surface-tinted",
    group: "surface",
    displayName: "Surface Tinted",
    description: {
      long: "Surface Tinted brukes p\xE5 flater som ligger opp\xE5 bakgrunnsfargene. Denne har et hint av farge i seg.",
      short: "Overflater / komponenter med et hint av farge i seg."
    },
    luminance: {
      light: 0.81,
      dark: 0.027,
      contrast: 0.015
    }
  },
  "surface-hover": {
    number: 5,
    name: "surface-hover",
    group: "surface",
    displayName: "Surface Hover",
    description: {
      long: "Surface Hover brukes p\xE5 interaktive flater som ligger opp\xE5 bakgrunnsfargene i en hover state.",
      short: "Hover-farge til overflater / komponenter."
    },
    luminance: {
      light: 0.7,
      dark: 0.036,
      contrast: 0.028
    }
  },
  "surface-active": {
    number: 6,
    name: "surface-active",
    group: "surface",
    displayName: "Surface Active",
    description: {
      long: "Surface Active brukes p\xE5 interaktive flater som ligger opp\xE5 bakgrunnsfargene i en active state.",
      short: "Active-farge til overflater / komponenter."
    },
    luminance: {
      light: 0.59,
      dark: 0.056,
      contrast: 0.045
    }
  },
  "border-subtle": {
    number: 7,
    name: "border-subtle",
    group: "border",
    displayName: "Border Subtle",
    description: {
      long: "Border Subtle er den lyseste border-fargen og brukes for \xE5 skille elementer fra hverandre.",
      short: "Border-farge med lav kontrast til dekorativ bruk (skillelinjer)."
    },
    luminance: {
      light: 0.5,
      dark: 0.08,
      contrast: 0.26
    }
  },
  "border-default": {
    number: 8,
    name: "border-default",
    group: "border",
    displayName: "Border Default",
    description: {
      long: "Border Default er en border-farge som brukes n\xE5r man \xF8nsker god kontrast mot bakgrunnsfargene.",
      short: "Standard border-farge til skjemakomponenter og meningsb\xE6rende elementer."
    },
    luminance: {
      light: 0.19,
      dark: 0.22,
      contrast: 0.4
    }
  },
  "border-strong": {
    number: 9,
    name: "border-strong",
    group: "border",
    displayName: "Border Strong",
    description: {
      long: "Border Strong er den m\xF8rkeste border-fargen og brukes n\xE5r man \xF8nsker en veldig tydelig og sterk border.",
      short: "Border-farge med h\xF8y kontrast for ekstra synlighet."
    },
    luminance: {
      light: 0.11,
      dark: 0.39,
      contrast: 0.6
    }
  },
  "text-subtle": {
    number: 10,
    name: "text-subtle",
    group: "text",
    displayName: "Text Subtle",
    description: {
      long: "Text Subtle er den lyseste tekstfargen og brukes p\xE5 tekst som skal v\xE6re litt mindre synlig eller for \xE5 skape variasjon i typografien.",
      short: "Tekst- og ikonfarge med lavere kontrast."
    },
    luminance: {
      light: 0.11,
      dark: 0.39,
      contrast: 0.57
    }
  },
  "text-default": {
    number: 11,
    name: "text-default",
    group: "text",
    displayName: "Text Default",
    description: {
      long: "Text Default er den m\xF8rkeste tekstfargen og brukes p\xE5 tekst som skal v\xE6re mest synlig. Denne fargen b\xF8r brukes p\xE5 mesteparten av teksten p\xE5 en side.",
      short: "Tekst- og ikonfarge med h\xF8y kontrast og god synlighet."
    },
    luminance: {
      light: 0.0245,
      dark: 0.84,
      contrast: 0.86
    }
  },
  "base-default": {
    number: 12,
    name: "base-default",
    group: "base",
    displayName: "Base Default",
    description: {
      long: "Base Default fargen f\xE5r den samme hex koden som fargen som er valgt i verkt\xF8yet. Brukes ofte som farge p\xE5 viktige elementer og p\xE5 flater som skal fange brukerens oppmerksomhet.",
      short: "Standardfarge for solide bakgrunner."
    },
    luminance: {
      light: 1,
      dark: 1,
      contrast: 1
    }
  },
  "base-hover": {
    number: 13,
    name: "base-hover",
    group: "base",
    displayName: "Base Hover",
    description: {
      long: "Base Hover brukes som hover farge p\xE5 elementer som bruker Base Default fargen.",
      short: "Hover-farge for solide bakgrunner."
    },
    luminance: {
      light: 1,
      dark: 1,
      contrast: 1
    }
  },
  "base-active": {
    number: 14,
    name: "base-active",
    group: "base",
    displayName: "Base Active",
    description: {
      long: "Base Active brukes som active farge p\xE5 elementer som bruker Base Default fargen.",
      short: "Active-farge for solide bakgrunner."
    },
    luminance: {
      light: 1,
      dark: 1,
      contrast: 1
    }
  },
  "base-contrast-subtle": {
    number: 15,
    name: "base-contrast-subtle",
    group: "base",
    displayName: "Contrast Subtle",
    description: {
      long: "Contrast Subtle brukes som en viktig meningsb\xE6rende farge opp\xE5 Base Default fargen.",
      short: "Farge med god kontrast mot Base-default."
    },
    luminance: {
      light: 1,
      dark: 1,
      contrast: 1
    }
  },
  "base-contrast-default": {
    number: 16,
    name: "base-contrast-default",
    group: "base",
    displayName: "Contrast Default",
    description: {
      long: "Contrast Default brukes som en viktig meningsb\xE6rende farge opp\xE5 alle Base fargane.",
      short: "Farge med god kontrast mot Base-default og Base-hover."
    },
    luminance: {
      light: 1,
      dark: 1,
      contrast: 1
    }
  }
};
var colorMetadataByNumber = R.indexBy((metadata) => metadata.number, Object.values(colorMetadata));
var getColorMetadataByNumber = (number) => {
  return colorMetadataByNumber[number];
};
var colorNames = Object.keys(colorMetadata);
var baseColorNames = Object.keys(baseColors);

// src/colors/theme.ts
import chroma2 from "chroma-js";
import * as R2 from "ramda";

// src/colors/utils.ts
import chroma from "chroma-js";
import Colorjs from "colorjs.io";
import { Hsluv } from "hsluv";
var hexToCssHsl = (hex, valuesOnly = false) => {
  const [h, s, l] = chroma(hex).hsl();
  const hRounded = Math.round(h);
  const sRounded = Math.round(s * 100);
  const lRounded = Math.round(l * 100);
  const cssString = `${hRounded},${sRounded}%,${lRounded}%`;
  return valuesOnly ? cssString : `hsl(${cssString})`;
};
var hexToHSL = (hex) => {
  const [h, s, l] = chroma(hex).hsl();
  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
};
var hexToHsluv = (hex) => {
  const conv = new Hsluv();
  conv.hex = hex;
  conv.hexToHsluv();
  return [conv.hsluv_h, conv.hsluv_s, conv.hsluv_l];
};
var hslArrToCss = (HSL) => {
  return "hsl(" + HSL[0] + "," + HSL[1] + "%," + HSL[2] + "%)";
};
var HSLToHex = (h, s, l) => {
  return chroma.hsl(h, s / 100, l / 100).hex();
};
var hexToRgb = (hex, type = "255") => {
  const rgb = chroma(hex).rgb();
  return {
    r: type === "255" ? rgb[0] : rgb[0] / 255,
    g: type === "255" ? rgb[1] : rgb[1] / 255,
    b: type === "255" ? rgb[2] : rgb[2] / 255
  };
};
var getContrastFromHex = (color1, color2) => {
  const lum1 = chroma(color1).luminance();
  const lum2 = chroma(color2).luminance();
  return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);
};
var getContrastFromLightness = (lightness, mainColor, backgroundColor) => {
  const conv = new Hsluv();
  conv.hex = mainColor;
  conv.hexToHsluv();
  conv.hsluv_l = lightness;
  conv.hsluvToHex();
  const lightMainColor = conv.hex;
  const lum1 = chroma(lightMainColor).luminance();
  const lum2 = chroma(backgroundColor).luminance();
  const ratio = (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);
  return ratio;
};
var areColorsContrasting = (color1, color2, type = "aa") => {
  const contrast = getContrastFromHex(color1, color2);
  if (contrast !== null) {
    if (type === "aaa") {
      return contrast >= 7;
    }
    if (type === "aa") {
      return contrast >= 4.5;
    }
    return contrast >= 3;
  }
  return false;
};
var isHexColor = (hex) => {
  return typeof hex === "string" && hex.length === 6 && !Number.isNaN(Number("0x" + hex));
};
var getLuminanceFromLightness = (lightness) => {
  const conv = new Hsluv();
  conv.hsluv_l = lightness;
  conv.hsluvToHex();
  return chroma(conv.hex).luminance();
};
var getLuminanceFromColor = (color) => {
  return chroma(color).luminance();
};
var getLightnessFromHex = (hex) => {
  const conv = new Hsluv();
  conv.hex = hex;
  conv.hexToHsluv();
  return conv.hsluv_l;
};
var canTextBeUsedOnColors = (baseDefaultColor, baseActiveColor) => {
  const defaultAgainstWhite = getContrastFromHex(baseDefaultColor, "#ffffff");
  const defaultAgainstBlack = getContrastFromHex(baseDefaultColor, "#000000");
  const activeAgainstWhite = getContrastFromHex(baseActiveColor, "#ffffff");
  const activeAgainstBlack = getContrastFromHex(baseActiveColor, "#000000");
  if (defaultAgainstWhite >= 4.5 && activeAgainstWhite >= 4.5) {
    return true;
  }
  if (defaultAgainstBlack >= 4.5 && activeAgainstBlack >= 4.5) {
    return true;
  }
  return false;
};
var convertToHex = (color) => {
  if (!color) {
    return "#000000";
  }
  if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
    return color;
  }
  return chroma(color).hex();
};
var rgbToHex = (rgb) => {
  return `#${[rgb.r, rgb.g, rgb.b].map((x) => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("")}`;
};
var convertColor = (cssColor, format) => {
  const color = new Colorjs(cssColor);
  switch (format) {
    case "rgb":
    case "rgba":
      return color.toString({
        format: {
          name: format,
          coords: ["<number>[0, 255]", "<number>[0, 255]", "<number>[0, 255]"]
        },
        precision: 3
      });
    case "hex":
      return color.toString({ format, precision: 3 });
    case "hct":
      return color.to(format).toString({
        format: {
          name: format,
          coords: ["<number>", "<number>", "<number>"]
        },
        precision: 3
      });
    default:
      return color.to(format).toString({ precision: 3 });
  }
};

// src/colors/theme.ts
var RESERVED_COLORS = ["neutral", "success", "warning", "danger", "info"];
var generateColorScale = (color, colorScheme2) => {
  let interpolationColor = color;
  if (colorScheme2 === "dark") {
    const [L, C, H] = chroma2(color).oklch();
    const chromaModifier = 0.7;
    interpolationColor = chroma2(L, C * chromaModifier, H, "oklch").hex();
  }
  const colors = R2.mapObjIndexed((colorData) => {
    const luminance = colorData.luminance[colorScheme2];
    return {
      ...colorData,
      hex: chroma2(interpolationColor).luminance(luminance).hex()
    };
  }, colorMetadata);
  const baseColors2 = generateBaseColors(color, colorScheme2);
  colors["base-default"] = { ...colors["base-default"], hex: baseColors2.default };
  colors["base-hover"] = { ...colors["base-hover"], hex: baseColors2.hover };
  colors["base-active"] = { ...colors["base-active"], hex: baseColors2.active };
  colors["base-contrast-subtle"] = {
    ...colors["base-contrast-subtle"],
    hex: generateColorContrast(baseColors2.default, "subtle")
  };
  colors["base-contrast-default"] = {
    ...colors["base-contrast-default"],
    hex: generateColorContrast(baseColors2.default, "default")
  };
  return Object.values(colors);
};
var generateColorSchemes = (color) => ({
  light: generateColorScale(color, "light"),
  dark: generateColorScale(color, "dark"),
  contrast: generateColorScale(color, "contrast")
});
var generateBaseColors = (color, colorScheme2) => {
  let colorLightness = getLightnessFromHex(color);
  if (colorScheme2 !== "light") {
    colorLightness = colorLightness <= 30 ? 70 : 100 - colorLightness;
  }
  const modifier = colorLightness <= 30 || colorLightness >= 49 && colorLightness <= 65 ? -8 : 8;
  const calculateLightness = (base, mod) => base - mod;
  return {
    default: colorScheme2 === "light" ? color : chroma2(color).luminance(getLuminanceFromLightness(colorLightness)).hex(),
    hover: chroma2(color).luminance(getLuminanceFromLightness(calculateLightness(colorLightness, modifier))).hex(),
    active: chroma2(color).luminance(getLuminanceFromLightness(calculateLightness(colorLightness, modifier * 2))).hex()
  };
};
var generateColorContrast = (color, type) => {
  if (type === "default") {
    return chroma2.contrast(color, "#ffffff") >= chroma2.contrast(color, "#000000") ? "#ffffff" : "#000000";
  }
  if (type === "subtle") {
    const contrastWhite = chroma2.contrast(color, "#ffffff");
    const contrastBlack = chroma2.contrast(color, "#000000");
    const lightness = getLightnessFromHex(color);
    const modifier = lightness <= 40 || lightness >= 60 ? 60 : 50;
    const targetLightness = contrastWhite >= contrastBlack ? lightness + modifier : lightness - modifier;
    return chroma2(color).luminance(getLuminanceFromLightness(targetLightness)).hex();
  }
  return color;
};
var getCssVariable = (colorType, colorNumber) => {
  return `--ds-color-${colorType}-${getColorMetadataByNumber(colorNumber).displayName.toLowerCase().replace(/\s/g, "-")}`;
};

// src/config.ts
import pc from "picocolors";
import * as R7 from "ramda";
import { z } from "zod";
import { fromError } from "zod-validation-error";

// src/tokens/create/defaults.ts
import * as R3 from "ramda";

// src/tokens/template/design-tokens/primitives/globals.json with { type: 'json' }
var globals_default = {
  "border-width": {
    "1": {
      $type: "borderWidth",
      $value: "1px"
    },
    "3": {
      $type: "borderWidth",
      $value: "3px"
    }
  },
  shadow: {
    "100": {
      $type: "boxShadow",
      $value: [
        {
          color: "rgba(0,0,0,0.16)",
          x: "0",
          y: "0",
          blur: "1",
          spread: "0"
        },
        {
          x: "0",
          y: "1",
          blur: "2",
          spread: "0",
          color: "rgba(0,0,0,0.12)"
        }
      ]
    },
    "200": {
      $type: "boxShadow",
      $value: [
        {
          color: "rgba(0,0,0,0.15)",
          x: "0",
          y: "0",
          blur: "1",
          spread: "0"
        },
        {
          color: "rgba(0,0,0,0.12)",
          x: "0",
          y: "1",
          blur: "2",
          spread: "0"
        },
        {
          x: "0",
          y: "2",
          blur: "4",
          spread: "0",
          color: "rgba(0,0,0,0.1)"
        }
      ]
    },
    "300": {
      $type: "boxShadow",
      $value: [
        {
          color: "rgba(0,0,0,0.14)",
          x: "0",
          y: "0",
          blur: "1",
          spread: "0"
        },
        {
          color: "rgba(0,0,0,0.12)",
          x: "0",
          y: "2",
          blur: "4",
          spread: "0"
        },
        {
          x: "0",
          y: "4",
          blur: "8",
          spread: "0",
          color: "rgba(0,0,0,0.12)"
        }
      ]
    },
    "400": {
      $type: "boxShadow",
      $value: [
        {
          color: "rgba(0,0,0,0.13)",
          x: "0",
          y: "0",
          blur: "1",
          spread: "0"
        },
        {
          color: "rgba(0,0,0,0.13)",
          x: "0",
          y: "3",
          blur: "5",
          spread: "0"
        },
        {
          x: "0",
          y: "6",
          blur: "12",
          spread: "0",
          color: "rgba(0,0,0,0.14)"
        }
      ]
    },
    "500": {
      $type: "boxShadow",
      $value: [
        {
          color: "rgba(0,0,0,0.12)",
          x: "0",
          y: "0",
          blur: "1",
          spread: "0"
        },
        {
          color: "rgba(0,0,0,0.16)",
          x: "0",
          y: "4",
          blur: "8",
          spread: "0"
        },
        {
          x: "0",
          y: "12",
          blur: "24",
          spread: "0",
          color: "rgba(0,0,0,0.16)"
        }
      ]
    }
  },
  opacity: {
    "30": {
      $type: "opacity",
      $value: "30%"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/size/global.json with { type: 'json' }
var global_default = {
  _size: {
    "0": {
      $type: "dimension",
      $value: "floor({_size.unit} * 0)"
    },
    "1": {
      $type: "dimension",
      $value: "floor({_size.unit} * 1)"
    },
    "2": {
      $type: "dimension",
      $value: "floor({_size.unit} * 2)"
    },
    "3": {
      $type: "dimension",
      $value: "floor({_size.unit} * 3)"
    },
    "4": {
      $type: "dimension",
      $value: "floor({_size.unit} * 4)"
    },
    "5": {
      $type: "dimension",
      $value: "floor({_size.unit} * 5)"
    },
    "6": {
      $type: "dimension",
      $value: "floor({_size.unit} * 6)"
    },
    "7": {
      $type: "dimension",
      $value: "floor({_size.unit} * 7)"
    },
    "8": {
      $type: "dimension",
      $value: "floor({_size.unit} * 8)"
    },
    "9": {
      $type: "dimension",
      $value: "floor({_size.unit} * 9)"
    },
    "10": {
      $type: "dimension",
      $value: "floor({_size.unit} * 10)"
    },
    "11": {
      $type: "dimension",
      $value: "floor({_size.unit} * 11)"
    },
    "12": {
      $type: "dimension",
      $value: "floor({_size.unit} * 12)"
    },
    "13": {
      $type: "dimension",
      $value: "floor({_size.unit} * 13)"
    },
    "14": {
      $type: "dimension",
      $value: "floor({_size.unit} * 14)"
    },
    "15": {
      $type: "dimension",
      $value: "floor({_size.unit} * 15)"
    },
    "18": {
      $type: "dimension",
      $value: "floor({_size.unit} * 18)"
    },
    "22": {
      $type: "dimension",
      $value: "floor({_size.unit} * 22)"
    },
    "26": {
      $type: "dimension",
      $value: "floor({_size.unit} * 26)"
    },
    "30": {
      $type: "dimension",
      $value: "floor({_size.unit} * 30)"
    },
    "mode-font-size": {
      $type: "number",
      $value: "{size._mode-font-size}"
    },
    base: {
      $type: "number",
      $value: "{size._base}"
    },
    step: {
      $type: "number",
      $value: "{size._step}"
    },
    unit: {
      $type: "number",
      $value: "{_size.step} / {_size.base} * {_size.mode-font-size}"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/size/large.json with { type: 'json' }
var large_default = {
  size: {
    "_mode-font-size": {
      $type: "dimension",
      $value: "21"
    },
    _base: {
      $type: "dimension",
      $value: "18"
    },
    _step: {
      $type: "dimension",
      $value: "4"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/size/medium.json with { type: 'json' }
var medium_default = {
  size: {
    "_mode-font-size": {
      $type: "dimension",
      $value: "18"
    },
    _base: {
      $type: "dimension",
      $value: "18"
    },
    _step: {
      $type: "dimension",
      $value: "4"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/size/small.json with { type: 'json' }
var small_default = {
  size: {
    "_mode-font-size": {
      $type: "dimension",
      $value: "16"
    },
    _base: {
      $type: "dimension",
      $value: "18"
    },
    _step: {
      $type: "dimension",
      $value: "4"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/typography/size/large.json with { type: 'json' }
var large_default2 = {
  "line-height": {
    sm: {
      $type: "lineHeights",
      $value: "130%"
    },
    md: {
      $type: "lineHeights",
      $value: "150%"
    },
    lg: {
      $type: "lineHeights",
      $value: "170%"
    }
  },
  "font-size": {
    "1": {
      $type: "fontSizes",
      $value: "13"
    },
    "2": {
      $type: "fontSizes",
      $value: "16"
    },
    "3": {
      $type: "fontSizes",
      $value: "18"
    },
    "4": {
      $type: "fontSizes",
      $value: "21"
    },
    "5": {
      $type: "fontSizes",
      $value: "24"
    },
    "6": {
      $type: "fontSizes",
      $value: "30"
    },
    "7": {
      $type: "fontSizes",
      $value: "36"
    },
    "8": {
      $type: "fontSizes",
      $value: "48"
    },
    "9": {
      $type: "fontSizes",
      $value: "60"
    },
    "10": {
      $type: "fontSizes",
      $value: "72"
    }
  },
  "letter-spacing": {
    "1": {
      $type: "letterSpacing",
      $value: "-1%"
    },
    "2": {
      $type: "letterSpacing",
      $value: "-0.5%"
    },
    "3": {
      $type: "letterSpacing",
      $value: "-0.25%"
    },
    "4": {
      $type: "letterSpacing",
      $value: "-0.15%"
    },
    "5": {
      $type: "letterSpacing",
      $value: "0%"
    },
    "6": {
      $type: "letterSpacing",
      $value: "0.15%"
    },
    "7": {
      $type: "letterSpacing",
      $value: "0.25%"
    },
    "8": {
      $type: "letterSpacing",
      $value: "0.5%"
    },
    "9": {
      $type: "letterSpacing",
      $value: "1.5%"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/typography/size/medium.json with { type: 'json' }
var medium_default2 = {
  "line-height": {
    sm: {
      $type: "lineHeights",
      $value: "130%"
    },
    md: {
      $type: "lineHeights",
      $value: "150%"
    },
    lg: {
      $type: "lineHeights",
      $value: "170%"
    }
  },
  "font-size": {
    "1": {
      $type: "fontSizes",
      $value: "12"
    },
    "2": {
      $type: "fontSizes",
      $value: "14"
    },
    "3": {
      $type: "fontSizes",
      $value: "16"
    },
    "4": {
      $type: "fontSizes",
      $value: "18"
    },
    "5": {
      $type: "fontSizes",
      $value: "21"
    },
    "6": {
      $type: "fontSizes",
      $value: "24"
    },
    "7": {
      $type: "fontSizes",
      $value: "30"
    },
    "8": {
      $type: "fontSizes",
      $value: "36"
    },
    "9": {
      $type: "fontSizes",
      $value: "48"
    },
    "10": {
      $type: "fontSizes",
      $value: "60"
    }
  },
  "letter-spacing": {
    "1": {
      $type: "letterSpacing",
      $value: "-1%"
    },
    "2": {
      $type: "letterSpacing",
      $value: "-0.5%"
    },
    "3": {
      $type: "letterSpacing",
      $value: "-0.25%"
    },
    "4": {
      $type: "letterSpacing",
      $value: "-0.15%"
    },
    "5": {
      $type: "letterSpacing",
      $value: "0%"
    },
    "6": {
      $type: "letterSpacing",
      $value: "0.15%"
    },
    "7": {
      $type: "letterSpacing",
      $value: "0.25%"
    },
    "8": {
      $type: "letterSpacing",
      $value: "0.5%"
    },
    "9": {
      $type: "letterSpacing",
      $value: "1.5%"
    }
  }
};

// src/tokens/template/design-tokens/primitives/modes/typography/size/small.json with { type: 'json' }
var small_default2 = {
  "line-height": {
    sm: {
      $type: "lineHeights",
      $value: "130%"
    },
    md: {
      $type: "lineHeights",
      $value: "150%"
    },
    lg: {
      $type: "lineHeights",
      $value: "170%"
    }
  },
  "font-size": {
    "1": {
      $type: "fontSizes",
      $value: "11"
    },
    "2": {
      $type: "fontSizes",
      $value: "13"
    },
    "3": {
      $type: "fontSizes",
      $value: "14"
    },
    "4": {
      $type: "fontSizes",
      $value: "16"
    },
    "5": {
      $type: "fontSizes",
      $value: "18"
    },
    "6": {
      $type: "fontSizes",
      $value: "21"
    },
    "7": {
      $type: "fontSizes",
      $value: "24"
    },
    "8": {
      $type: "fontSizes",
      $value: "30"
    },
    "9": {
      $type: "fontSizes",
      $value: "36"
    },
    "10": {
      $type: "fontSizes",
      $value: "48"
    }
  },
  "letter-spacing": {
    "1": {
      $type: "letterSpacing",
      $value: "-1%"
    },
    "2": {
      $type: "letterSpacing",
      $value: "-0.5%"
    },
    "3": {
      $type: "letterSpacing",
      $value: "-0.25%"
    },
    "4": {
      $type: "letterSpacing",
      $value: "-0.15%"
    },
    "5": {
      $type: "letterSpacing",
      $value: "0%"
    },
    "6": {
      $type: "letterSpacing",
      $value: "0.15%"
    },
    "7": {
      $type: "letterSpacing",
      $value: "0.25%"
    },
    "8": {
      $type: "letterSpacing",
      $value: "0.5%"
    },
    "9": {
      $type: "letterSpacing",
      $value: "1.5%"
    }
  }
};

// src/tokens/template/design-tokens/semantic/style.json with { type: 'json' }
var style_default = {
  typography: {
    heading: {
      "2xl": {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.10}",
          letterSpacing: "{letter-spacing.1}"
        }
      },
      xl: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.9}",
          letterSpacing: "{letter-spacing.1}"
        }
      },
      lg: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.8}",
          letterSpacing: "{letter-spacing.2}"
        }
      },
      md: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.7}",
          letterSpacing: "{letter-spacing.3}"
        }
      },
      sm: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.6}",
          letterSpacing: "{letter-spacing.5}"
        }
      },
      xs: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.5}",
          letterSpacing: "{letter-spacing.6}"
        }
      },
      "2xs": {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.medium}",
          lineHeight: "{line-height.sm}",
          fontSize: "{font-size.4}",
          letterSpacing: "{letter-spacing.6}"
        }
      }
    },
    body: {
      xl: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.regular}",
          lineHeight: "{line-height.md}",
          fontSize: "{font-size.6}",
          letterSpacing: "{letter-spacing.8}"
        }
      },
      lg: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.regular}",
          lineHeight: "{line-height.md}",
          fontSize: "{font-size.5}",
          letterSpacing: "{letter-spacing.8}"
        }
      },
      md: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.regular}",
          lineHeight: "{line-height.md}",
          fontSize: "{font-size.4}",
          letterSpacing: "{letter-spacing.8}"
        }
      },
      sm: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.regular}",
          lineHeight: "{line-height.md}",
          fontSize: "{font-size.3}",
          letterSpacing: "{letter-spacing.7}"
        }
      },
      xs: {
        $type: "typography",
        $value: {
          fontFamily: "{font-family}",
          fontWeight: "{font-weight.regular}",
          lineHeight: "{line-height.md}",
          fontSize: "{font-size.2}",
          letterSpacing: "{letter-spacing.6}"
        }
      },
      short: {
        xl: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.sm}",
            fontSize: "{font-size.6}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        lg: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.sm}",
            fontSize: "{font-size.5}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        md: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.sm}",
            fontSize: "{font-size.4}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        sm: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.sm}",
            fontSize: "{font-size.3}",
            letterSpacing: "{letter-spacing.7}"
          }
        },
        xs: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.sm}",
            fontSize: "{font-size.2}",
            letterSpacing: "{letter-spacing.6}"
          }
        }
      },
      long: {
        xl: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.lg}",
            fontSize: "{font-size.6}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        lg: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.lg}",
            fontSize: "{font-size.5}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        md: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.lg}",
            fontSize: "{font-size.4}",
            letterSpacing: "{letter-spacing.8}"
          }
        },
        sm: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.lg}",
            fontSize: "{font-size.3}",
            letterSpacing: "{letter-spacing.7}"
          }
        },
        xs: {
          $type: "typography",
          $value: {
            fontFamily: "{font-family}",
            fontWeight: "{font-weight.regular}",
            lineHeight: "{line-height.lg}",
            fontSize: "{font-size.2}",
            letterSpacing: "{letter-spacing.6}"
          }
        }
      }
    }
  },
  opacity: {
    disabled: {
      $type: "opacity",
      $value: "{opacity.30}"
    }
  },
  "border-width": {
    default: {
      $type: "borderWidth",
      $value: "{border-width.1}"
    },
    focus: {
      $type: "borderWidth",
      $value: "{border-width.3}"
    }
  },
  shadow: {
    xs: {
      $type: "boxShadow",
      $value: "{shadow.100}"
    },
    sm: {
      $type: "boxShadow",
      $value: "{shadow.200}"
    },
    md: {
      $type: "boxShadow",
      $value: "{shadow.300}"
    },
    lg: {
      $type: "boxShadow",
      $value: "{shadow.400}"
    },
    xl: {
      $type: "boxShadow",
      $value: "{shadow.500}"
    }
  },
  "border-radius": {
    sm: {
      $type: "dimension",
      $value: "{border-radius.1}"
    },
    md: {
      $type: "dimension",
      $value: "{border-radius.2}"
    },
    lg: {
      $type: "dimension",
      $value: "{border-radius.3}"
    },
    xl: {
      $type: "dimension",
      $value: "{border-radius.4}"
    },
    default: {
      $type: "dimension",
      $value: "{border-radius.5}"
    },
    full: {
      $type: "dimension",
      $value: "{border-radius.6}"
    }
  },
  size: {
    "0": {
      $type: "dimension",
      $value: "{_size.0}"
    },
    "1": {
      $type: "dimension",
      $value: "{_size.1}"
    },
    "2": {
      $type: "dimension",
      $value: "{_size.2}"
    },
    "3": {
      $type: "dimension",
      $value: "{_size.3}"
    },
    "4": {
      $type: "dimension",
      $value: "{_size.4}"
    },
    "5": {
      $type: "dimension",
      $value: "{_size.5}"
    },
    "6": {
      $type: "dimension",
      $value: "{_size.6}"
    },
    "7": {
      $type: "dimension",
      $value: "{_size.7}"
    },
    "8": {
      $type: "dimension",
      $value: "{_size.8}"
    },
    "9": {
      $type: "dimension",
      $value: "{_size.9}"
    },
    "10": {
      $type: "dimension",
      $value: "{_size.10}"
    },
    "11": {
      $type: "dimension",
      $value: "{_size.11}"
    },
    "12": {
      $type: "dimension",
      $value: "{_size.12}"
    },
    "13": {
      $type: "dimension",
      $value: "{_size.13}"
    },
    "14": {
      $type: "dimension",
      $value: "{_size.14}"
    },
    "15": {
      $type: "dimension",
      $value: "{_size.15}"
    },
    "18": {
      $type: "dimension",
      $value: "{_size.18}"
    },
    "22": {
      $type: "dimension",
      $value: "{_size.22}"
    },
    "26": {
      $type: "dimension",
      $value: "{_size.26}"
    },
    "30": {
      $type: "dimension",
      $value: "{_size.30}"
    }
  }
};

// src/tokens/create/defaults.ts
var defaultTokens = {
  "primitives/globals": globals_default,
  "primitives/modes/size/small": small_default,
  "primitives/modes/size/medium": medium_default,
  "primitives/modes/size/large": large_default,
  "primitives/modes/size/global": global_default,
  "primitives/modes/typography/size/small": small_default2,
  "primitives/modes/typography/size/medium": medium_default2,
  "primitives/modes/typography/size/large": large_default2,
  "semantic/style": style_default
};
var getDefaultTokens = (tokenSets) => Object.entries(R3.pick(tokenSets, defaultTokens));
var getDefaultToken = (tokenPath) => {
  return [tokenPath, defaultTokens[tokenPath]];
};

// src/tokens/create/generators/color.ts
import * as R4 from "ramda";
var generateColor = (colorArray, overrides) => {
  const obj = {};
  const $type = "color";
  for (const index in colorArray) {
    const position = Number(index) + 1;
    const overrideValue = overrides?.[position];
    obj[position] = {
      $type,
      $value: overrideValue || colorArray[index].hex
    };
  }
  return obj;
};
var generateColorScheme = (themeName, colorScheme2, colors, overrides) => {
  const createColorOverrides = (colorName) => {
    if (!overrides?.colors || !(colorName in overrides.colors)) {
      return void 0;
    }
    const colorOverrides = overrides.colors[colorName];
    const positionOverrides = {};
    Object.entries(colorOverrides).forEach(([semanticTokenName, modeOverrides]) => {
      const position = colorMetadata[semanticTokenName].number;
      if (position) {
        let overrideValue;
        if (colorScheme2 === "light" && modeOverrides.light) {
          overrideValue = modeOverrides.light;
        } else if (colorScheme2 === "dark" && modeOverrides.dark) {
          overrideValue = modeOverrides.dark;
        }
        if (overrideValue) {
          positionOverrides[position] = overrideValue;
        }
      }
    });
    return Object.keys(positionOverrides).length > 0 ? positionOverrides : void 0;
  };
  const main = R4.mapObjIndexed(
    (color, colorName) => generateColor(generateColorScale(color, colorScheme2), createColorOverrides(colorName)),
    colors.main
  );
  const support = R4.mapObjIndexed(
    (color, colorName) => generateColor(generateColorScale(color, colorScheme2), createColorOverrides(colorName)),
    colors.support
  );
  const neutral = generateColor(generateColorScale(colors.neutral, colorScheme2), createColorOverrides("neutral"));
  const baseColorsWithOverrides = {
    ...baseColors,
    ...overrides?.severity
  };
  const globalColors = R4.mapObjIndexed(
    (color, colorName) => generateColor(generateColorScale(color, colorScheme2), createColorOverrides(colorName)),
    baseColorsWithOverrides
  );
  const linkColor = generateColor(generateColorScale(dsLinkColor, colorScheme2));
  return {
    [themeName]: {
      ...main,
      ...support,
      neutral,
      ...globalColors,
      link: {
        visited: linkColor[12]
      }
    }
  };
};

// src/tokens/create/generators/semantic.ts
import * as R5 from "ramda";

// src/tokens/template/design-tokens/semantic/color.base.template.json with { type: 'json' }
var color_base_template_default = {
  color: {
    focus: {
      inner: {
        $type: "color",
        $value: "{color.neutral.background-default}"
      },
      outer: {
        $type: "color",
        $value: "{color.neutral.text-default}"
      }
    }
  },
  link: {
    color: {
      visited: {
        $type: "color",
        $value: "{color.link.visited}"
      }
    }
  }
};

// src/tokens/template/design-tokens/semantic/color.template.json with { type: 'json' }
var color_template_default = {
  "background-default": {
    $type: "color",
    $value: "{color.<color>.1}"
  },
  "background-tinted": {
    $type: "color",
    $value: "{color.<color>.2}"
  },
  "surface-default": {
    $type: "color",
    $value: "{color.<color>.3}"
  },
  "surface-tinted": {
    $type: "color",
    $value: "{color.<color>.4}"
  },
  "surface-hover": {
    $type: "color",
    $value: "{color.<color>.5}"
  },
  "surface-active": {
    $type: "color",
    $value: "{color.<color>.6}"
  },
  "border-subtle": {
    $type: "color",
    $value: "{color.<color>.7}"
  },
  "border-default": {
    $type: "color",
    $value: "{color.<color>.8}"
  },
  "border-strong": {
    $type: "color",
    $value: "{color.<color>.9}"
  },
  "text-subtle": {
    $type: "color",
    $value: "{color.<color>.10}"
  },
  "text-default": {
    $type: "color",
    $value: "{color.<color>.11}"
  },
  "base-default": {
    $type: "color",
    $value: "{color.<color>.12}"
  },
  "base-hover": {
    $type: "color",
    $value: "{color.<color>.13}"
  },
  "base-active": {
    $type: "color",
    $value: "{color.<color>.14}"
  },
  "base-contrast-subtle": {
    $type: "color",
    $value: "{color.<color>.15}"
  },
  "base-contrast-default": {
    $type: "color",
    $value: "{color.<color>.16}"
  }
};

// src/tokens/template/design-tokens/semantic/modes/color.template.json with { type: 'json' }
var color_template_default2 = {
  "background-default": {
    $type: "color",
    $value: "{color.<color>.background-default}"
  },
  "background-tinted": {
    $type: "color",
    $value: "{color.<color>.background-tinted}"
  },
  "surface-default": {
    $type: "color",
    $value: "{color.<color>.surface-default}"
  },
  "surface-tinted": {
    $type: "color",
    $value: "{color.<color>.surface-tinted}"
  },
  "surface-hover": {
    $type: "color",
    $value: "{color.<color>.surface-hover}"
  },
  "surface-active": {
    $type: "color",
    $value: "{color.<color>.surface-active}"
  },
  "border-subtle": {
    $type: "color",
    $value: "{color.<color>.border-subtle}"
  },
  "border-default": {
    $type: "color",
    $value: "{color.<color>.border-default}"
  },
  "border-strong": {
    $type: "color",
    $value: "{color.<color>.border-strong}"
  },
  "text-subtle": {
    $type: "color",
    $value: "{color.<color>.text-subtle}"
  },
  "text-default": {
    $type: "color",
    $value: "{color.<color>.text-default}"
  },
  "base-default": {
    $type: "color",
    $value: "{color.<color>.base-default}"
  },
  "base-hover": {
    $type: "color",
    $value: "{color.<color>.base-hover}"
  },
  "base-active": {
    $type: "color",
    $value: "{color.<color>.base-active}"
  },
  "base-contrast-subtle": {
    $type: "color",
    $value: "{color.<color>.base-contrast-subtle}"
  },
  "base-contrast-default": {
    $type: "color",
    $value: "{color.<color>.base-contrast-default}"
  }
};

// src/tokens/create/generators/semantic.ts
var generateSemantic = (colors, _themeName) => {
  const mainColorNames = Object.keys(colors.main);
  const supportColorNames = Object.keys(colors.support);
  const modes = {
    "main-color": {},
    "support-color": {}
  };
  const categories = [
    ["main-color", mainColorNames],
    ["support-color", supportColorNames]
  ];
  for (const [colorCategory2, colorNames2] of categories) {
    for (const colorName of colorNames2) {
      const category = colorCategory2.replace("-color", "");
      const customColorTokens = {
        color: {
          [category]: JSON.parse(
            JSON.stringify(
              color_template_default2,
              (key, value) => {
                if (key === "$value") {
                  return value.replace("<color>", colorName);
                }
                return value;
              },
              2
            )
          )
        }
      };
      modes[colorCategory2][colorName] = customColorTokens;
    }
  }
  const customColors = [...mainColorNames, "neutral", ...supportColorNames];
  const allColors = [...customColors, ...baseColorNames];
  const semanticColorTokens = allColors.map(
    (colorName) => [
      colorName,
      R5.map((x) => ({ ...x, $value: x.$value.replace("<color>", colorName) }), color_template_default)
    ]
  );
  const color = {
    ...color_base_template_default,
    color: {
      ...Object.fromEntries(semanticColorTokens),
      ...color_base_template_default.color
    }
  };
  return {
    modes,
    color
  };
};

// src/tokens/create/generators/theme.ts
import * as R6 from "ramda";

// src/tokens/template/design-tokens/themes/theme.base.template.json with { type: 'json' }
var theme_base_template_default = {
  color: {},
  "font-family": {
    $type: "fontFamilies",
    $value: "{<theme>.font-family}"
  },
  "font-weight": {
    medium: {
      $type: "fontWeights",
      $value: "{<theme>.font-weight.medium}"
    },
    semibold: {
      $type: "fontWeights",
      $value: "{<theme>.font-weight.semibold}"
    },
    regular: {
      $type: "fontWeights",
      $value: "{<theme>.font-weight.regular}"
    }
  },
  "border-radius": {
    "1": {
      $type: "dimension",
      $value: "min({border-radius.base}*0.5,{border-radius.scale})"
    },
    "2": {
      $type: "dimension",
      $value: "min({border-radius.base},{border-radius.scale}*2)"
    },
    "3": {
      $type: "dimension",
      $value: "min({border-radius.base}*2,{border-radius.scale}*5)"
    },
    "4": {
      $type: "dimension",
      $value: "min({border-radius.base}*3,{border-radius.scale}*7)"
    },
    "5": {
      $type: "dimension",
      $value: "{border-radius.base}"
    },
    "6": {
      $type: "dimension",
      $value: "9999"
    },
    base: {
      $type: "dimension",
      $value: "4"
    },
    scale: {
      $type: "dimension",
      $value: "4"
    }
  }
};

// src/tokens/template/design-tokens/themes/theme.template.json with { type: 'json' }
var theme_template_default = {
  "1": {
    $type: "color",
    $value: "{<theme>.<color>.1}"
  },
  "2": {
    $type: "color",
    $value: "{<theme>.<color>.2}"
  },
  "3": {
    $type: "color",
    $value: "{<theme>.<color>.3}"
  },
  "4": {
    $type: "color",
    $value: "{<theme>.<color>.4}"
  },
  "5": {
    $type: "color",
    $value: "{<theme>.<color>.5}"
  },
  "6": {
    $type: "color",
    $value: "{<theme>.<color>.6}"
  },
  "7": {
    $type: "color",
    $value: "{<theme>.<color>.7}"
  },
  "8": {
    $type: "color",
    $value: "{<theme>.<color>.8}"
  },
  "9": {
    $type: "color",
    $value: "{<theme>.<color>.9}"
  },
  "10": {
    $type: "color",
    $value: "{<theme>.<color>.10}"
  },
  "11": {
    $type: "color",
    $value: "{<theme>.<color>.11}"
  },
  "12": {
    $type: "color",
    $value: "{<theme>.<color>.12}"
  },
  "13": {
    $type: "color",
    $value: "{<theme>.<color>.13}"
  },
  "14": {
    $type: "color",
    $value: "{<theme>.<color>.14}"
  },
  "15": {
    $type: "color",
    $value: "{<theme>.<color>.15}"
  },
  "16": {
    $type: "color",
    $value: "{<theme>.<color>.16}"
  }
};

// src/tokens/create/generators/theme.ts
var generateTheme = (colors, themeName, borderRadius) => {
  const mainColorNames = Object.keys(colors.main);
  const supportColorNames = Object.keys(colors.support);
  const customColors = [...mainColorNames, "neutral", ...supportColorNames, ...baseColorNames];
  const themeColorTokens = Object.fromEntries(
    customColors.map(
      (colorName) => [
        colorName,
        R6.map((x) => ({ ...x, $value: x.$value.replace("<color>", colorName) }), theme_template_default)
      ]
    )
  );
  const { color: themeBaseFileColor, ...remainingThemeFile } = theme_base_template_default;
  const themeFile = {
    color: {
      ...themeColorTokens,
      ...themeBaseFileColor,
      link: {
        visited: {
          $type: "color",
          $value: `{${themeName}.link.visited}`
        }
      }
    },
    ...remainingThemeFile
  };
  const baseBorderRadius = R6.lensPath(["border-radius", "base", "$value"]);
  const updatedThemeFile = R6.set(baseBorderRadius, String(borderRadius), themeFile);
  const token = JSON.parse(
    JSON.stringify(
      updatedThemeFile,
      (key, value) => {
        if (key === "$value") {
          return value.replace("<theme>", themeName);
        }
        return value;
      },
      2
    )
  );
  return token;
};

// src/tokens/template/design-tokens/primitives/modes/typography/typography.template.json with { type: 'json' }
var typography_template_default = {
  "<theme>": {
    "font-family": {
      $type: "fontFamilies",
      $value: "<font-family>"
    },
    "font-weight": {
      medium: {
        $type: "fontWeights",
        $value: "Medium"
      },
      semibold: {
        $type: "fontWeights",
        $value: "Semi bold"
      },
      regular: {
        $type: "fontWeights",
        $value: "Regular"
      }
    }
  }
};

// src/tokens/create/generators/typography.ts
var generateTypography = (themeName, { fontFamily }) => {
  return JSON.parse(
    JSON.stringify(typography_template_default).replaceAll(/<font-family>/g, fontFamily).replaceAll(/<theme>/g, themeName)
  );
};

// src/tokens/create.ts
var cliOptions = {
  outDir: "out-dir",
  clean: "clean",
  tailwind: "tailwind",
  theme: {
    colors: {
      main: "main-colors",
      support: "support-colors",
      neutral: "neutral-color"
    },
    typography: {
      fontFamily: "font-family"
    },
    borderRadius: "border-radius"
  }
};
var createTokens = async (opts) => {
  const { colors, typography: typography2, name, borderRadius, overrides } = opts;
  const colorSchemes = ["light", "dark"];
  const semantic2 = generateSemantic(colors, name);
  const tokenSets = new Map([
    ...getDefaultTokens([
      "primitives/globals",
      "primitives/modes/size/small",
      "primitives/modes/size/medium",
      "primitives/modes/size/large",
      "primitives/modes/size/global",
      "primitives/modes/typography/size/small",
      "primitives/modes/typography/size/medium",
      "primitives/modes/typography/size/large"
    ]),
    [`primitives/modes/typography/primary/${name}`, generateTypography(name, typography2)],
    [`primitives/modes/typography/secondary/${name}`, generateTypography(name, typography2)],
    ...colorSchemes.flatMap((scheme) => [
      [`primitives/modes/color-scheme/${scheme}/${name}`, generateColorScheme(name, scheme, colors, overrides)]
    ]),
    [`themes/${name}`, generateTheme(colors, name, borderRadius)],
    ["semantic/color", semantic2.color],
    // maps out semantic modes, ieg 'semantic/modes/main-color/accent', and 'semantic/modes/support-color/brand1'
    ...Object.entries(semantic2.modes).flatMap(
      ([mode, colors2]) => Object.entries(colors2).map(([key, colorSet]) => [`semantic/modes/${mode}/${key}`, colorSet])
    ),
    getDefaultToken("semantic/style")
  ]);
  return { tokenSets };
};

// src/config.ts
var hexPatterns = [
  // Hex colors: #000, #0000, #000000, #00000000
  `#[0-9a-fA-F]{3}`,
  `#[0-9a-fA-F]{4}`,
  `#[0-9a-fA-F]{6}`,
  `#[0-9a-fA-F]{8}`
];
var reservedColorsPattern = `^(?!(?:${RESERVED_COLORS.join("|")})$)`;
var colorRegex = new RegExp(`^${hexPatterns.join("|")}$`);
var colorSchema = z.string().regex(colorRegex).transform(convertToHex).describe(
  `A hex color, which is used for creating a color scale. Invalid color names: ${RESERVED_COLORS.join(", ")}`
);
var colorCategorySchema = z.record(
  z.string().regex(new RegExp(reservedColorsPattern, "i"), {
    error: `Color names cannot include reserved names: ${RESERVED_COLORS.join(", ")}`
  }),
  colorSchema,
  {
    error: "Color definitions must be hex color values"
  }
).refine((colors) => !Object.keys(colors).some((key) => RESERVED_COLORS.includes(key.toLowerCase())), {
  error: `Color names cannot include reserved names: ${RESERVED_COLORS.join(", ")}`
}).describe("An object with one or more color definitions. The property name is used as the color name.");
var colorModeOverrideSchema = z.object({
  light: colorSchema.optional(),
  dark: colorSchema.optional()
}).describe('Override values for semantic color tokens like "background-subtle", "border-default", etc.');
var colorWeightOverrideSchema = z.partialRecord(z.enum([...colorNames]), colorModeOverrideSchema).describe('The name of the color to add overrides for, e.g. "accent"');
var semanticColorOverrideSchema = z.record(z.string(), colorWeightOverrideSchema).describe("An object with color names as keys");
var severityColorOverrideSchema = z.partialRecord(z.enum(baseColorNames), colorSchema.describe("A hex color, which is used for creating a color scale")).optional().describe("An object with severity color names as keys");
var overridesSchema = z.object({
  colors: semanticColorOverrideSchema.optional(),
  severity: severityColorOverrideSchema.optional()
}).describe("Overrides for generated design tokens. Currently only supports colors defined in your theme").optional();
var themeSchema = z.object({
  colors: z.object({
    main: colorCategorySchema,
    support: colorCategorySchema.optional().default({}),
    neutral: colorSchema
  }).meta({ description: "Defines the colors for this theme" }),
  typography: z.object({
    fontFamily: z.string().meta({ description: "Sets the font-family for this theme" })
  }).describe("Defines the typography for a given theme").optional(),
  borderRadius: z.number().meta({ description: "Defines the border-radius for this theme" }).optional(),
  overrides: overridesSchema
}).meta({ description: "An object defining a theme. The property name holding the object becomes the theme name." });
var commonConfig = z.object({
  clean: z.boolean().meta({ description: "Delete the output directory before building or creating tokens" }).optional()
});
var _configFileCreateSchema = z.object({
  outDir: z.string().meta({ description: "Path to the output directory for the created design tokens" }),
  themes: z.record(z.string(), themeSchema).meta({
    description: "An object with one or more themes. Each property defines a theme, and the property name is used as the theme name."
  })
}).required();
var configFileCreateSchema = _configFileCreateSchema.extend(commonConfig.shape);

// src/tokens/format.ts
import * as R24 from "ramda";

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BoxShadowTypes.js
var BoxShadowTypes;
(function(BoxShadowTypes2) {
  BoxShadowTypes2["DROP_SHADOW"] = "dropShadow";
  BoxShadowTypes2["INNER_SHADOW"] = "innerShadow";
})(BoxShadowTypes || (BoxShadowTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/ColorModifierTypes.js
var ColorModifierTypes;
(function(ColorModifierTypes2) {
  ColorModifierTypes2["LIGHTEN"] = "lighten";
  ColorModifierTypes2["DARKEN"] = "darken";
  ColorModifierTypes2["MIX"] = "mix";
  ColorModifierTypes2["ALPHA"] = "alpha";
})(ColorModifierTypes || (ColorModifierTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/ColorSpaceTypes.js
var ColorSpaceTypes;
(function(ColorSpaceTypes2) {
  ColorSpaceTypes2["LCH"] = "lch";
  ColorSpaceTypes2["SRGB"] = "srgb";
  ColorSpaceTypes2["P3"] = "p3";
  ColorSpaceTypes2["HSL"] = "hsl";
})(ColorSpaceTypes || (ColorSpaceTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/Properties.js
var Properties;
(function(Properties2) {
  Properties2["sizing"] = "sizing";
  Properties2["height"] = "height";
  Properties2["width"] = "width";
  Properties2["spacing"] = "spacing";
  Properties2["verticalPadding"] = "verticalPadding";
  Properties2["horizontalPadding"] = "horizontalPadding";
  Properties2["paddingTop"] = "paddingTop";
  Properties2["paddingRight"] = "paddingRight";
  Properties2["paddingBottom"] = "paddingBottom";
  Properties2["paddingLeft"] = "paddingLeft";
  Properties2["itemSpacing"] = "itemSpacing";
  Properties2["fill"] = "fill";
  Properties2["backgroundBlur"] = "backgroundBlur";
  Properties2["border"] = "border";
  Properties2["borderTop"] = "borderTop";
  Properties2["borderRight"] = "borderRight";
  Properties2["borderBottom"] = "borderBottom";
  Properties2["borderLeft"] = "borderLeft";
  Properties2["borderColor"] = "borderColor";
  Properties2["borderRadius"] = "borderRadius";
  Properties2["borderRadiusTopLeft"] = "borderRadiusTopLeft";
  Properties2["borderRadiusTopRight"] = "borderRadiusTopRight";
  Properties2["borderRadiusBottomRight"] = "borderRadiusBottomRight";
  Properties2["borderRadiusBottomLeft"] = "borderRadiusBottomLeft";
  Properties2["borderWidth"] = "borderWidth";
  Properties2["borderWidthTop"] = "borderWidthTop";
  Properties2["borderWidthRight"] = "borderWidthRight";
  Properties2["borderWidthBottom"] = "borderWidthBottom";
  Properties2["borderWidthLeft"] = "borderWidthLeft";
  Properties2["boxShadow"] = "boxShadow";
  Properties2["opacity"] = "opacity";
  Properties2["fontFamilies"] = "fontFamilies";
  Properties2["fontWeights"] = "fontWeights";
  Properties2["fontSizes"] = "fontSizes";
  Properties2["lineHeights"] = "lineHeights";
  Properties2["typography"] = "typography";
  Properties2["composition"] = "composition";
  Properties2["letterSpacing"] = "letterSpacing";
  Properties2["paragraphSpacing"] = "paragraphSpacing";
  Properties2["textCase"] = "textCase";
  Properties2["dimension"] = "dimension";
  Properties2["textDecoration"] = "textDecoration";
  Properties2["asset"] = "asset";
  Properties2["tokenValue"] = "tokenValue";
  Properties2["value"] = "value";
  Properties2["tokenName"] = "tokenName";
  Properties2["description"] = "description";
})(Properties || (Properties = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TokenSetStatus.js
var TokenSetStatus;
(function(TokenSetStatus2) {
  TokenSetStatus2["DISABLED"] = "disabled";
  TokenSetStatus2["SOURCE"] = "source";
  TokenSetStatus2["ENABLED"] = "enabled";
})(TokenSetStatus || (TokenSetStatus = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TokenTypes.js
var TokenTypes;
(function(TokenTypes2) {
  TokenTypes2["OTHER"] = "other";
  TokenTypes2["COLOR"] = "color";
  TokenTypes2["BORDER_RADIUS"] = "borderRadius";
  TokenTypes2["SIZING"] = "sizing";
  TokenTypes2["SPACING"] = "spacing";
  TokenTypes2["TEXT"] = "text";
  TokenTypes2["TYPOGRAPHY"] = "typography";
  TokenTypes2["OPACITY"] = "opacity";
  TokenTypes2["BORDER_WIDTH"] = "borderWidth";
  TokenTypes2["STROKE_STYLE"] = "strokeStyle";
  TokenTypes2["BOX_SHADOW"] = "boxShadow";
  TokenTypes2["FONT_FAMILIES"] = "fontFamilies";
  TokenTypes2["FONT_WEIGHTS"] = "fontWeights";
  TokenTypes2["LINE_HEIGHTS"] = "lineHeights";
  TokenTypes2["FONT_SIZES"] = "fontSizes";
  TokenTypes2["LETTER_SPACING"] = "letterSpacing";
  TokenTypes2["PARAGRAPH_SPACING"] = "paragraphSpacing";
  TokenTypes2["PARAGRAPH_INDENT"] = "paragraphIndent";
  TokenTypes2["TEXT_DECORATION"] = "textDecoration";
  TokenTypes2["TEXT_CASE"] = "textCase";
  TokenTypes2["COMPOSITION"] = "composition";
  TokenTypes2["DIMENSION"] = "dimension";
  TokenTypes2["BORDER"] = "border";
  TokenTypes2["ASSET"] = "asset";
  TokenTypes2["BOOLEAN"] = "boolean";
  TokenTypes2["NUMBER"] = "number";
})(TokenTypes || (TokenTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BorderValues.js
var BorderValues;
(function(BorderValues2) {
  BorderValues2["BORDER_COLOR"] = "color";
  BorderValues2["BORDER_WIDTH"] = "width";
  BorderValues2["BORDER_STYLE"] = "style";
})(BorderValues || (BorderValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/StrokeStyleValues.js
var StrokeStyleValues;
(function(StrokeStyleValues2) {
  StrokeStyleValues2["SOLID"] = "solid";
  StrokeStyleValues2["DASHED"] = "dashed";
  StrokeStyleValues2["DOTTED"] = "dotted";
  StrokeStyleValues2["DOUBLE"] = "double";
  StrokeStyleValues2["GROOVE"] = "groove";
  StrokeStyleValues2["RIDGE"] = "ridge";
  StrokeStyleValues2["OUTSET"] = "outset";
  StrokeStyleValues2["INSET"] = "inset";
})(StrokeStyleValues || (StrokeStyleValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BoxShadowValues.js
var BoxShadowValues;
(function(BoxShadowValues2) {
  BoxShadowValues2["TYPE"] = "type";
  BoxShadowValues2["COLOR"] = "color";
  BoxShadowValues2["X"] = "x";
  BoxShadowValues2["Y"] = "y";
  BoxShadowValues2["BLUR"] = "blur";
  BoxShadowValues2["SPREAD"] = "spread";
  BoxShadowValues2["BLEND_MODE"] = "blendMode";
})(BoxShadowValues || (BoxShadowValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TypographyValues.js
var TypographyValues;
(function(TypographyValues2) {
  TypographyValues2["FONT_FAMILY"] = "fontFamily";
  TypographyValues2["FONT_WEIGHT"] = "fontWeight";
  TypographyValues2["LINE_HEIGHT"] = "lineHeight";
  TypographyValues2["FONT_SIZE"] = "fontSize";
  TypographyValues2["LETTER_SPACING"] = "letterSpacing";
  TypographyValues2["PARAGRAPH_SPACING"] = "paragraphSpacing";
  TypographyValues2["PARAGRAPH_INDENT"] = "paragraphIndent";
  TypographyValues2["TEXT_DECORATION"] = "textDecoration";
  TypographyValues2["TEXT_CASE"] = "textCase";
})(TypographyValues || (TypographyValues = {}));

// src/tokens/create/generators/$themes.ts
var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
async function createHash(text, algo = "SHA-1") {
  const crypto = globalThis.crypto;
  return Array.from(
    new Uint8Array(await crypto.subtle.digest(algo, new TextEncoder().encode(text))),
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
}
async function generate$Themes(colorSchemes, themes, colors) {
  return [
    ...generateSizeGroup(),
    ...await generateThemesGroup(themes),
    ...generateTypographyGroup(themes),
    ...generateColorSchemesGroup(colorSchemes, themes),
    generateSemanticGroup(),
    ...await generateColorGroup("main", colors),
    ...await generateColorGroup("support", colors)
  ];
}
function generateSizeGroup() {
  return [
    {
      id: "8b2c8cc86611a34b135cb22948666779361fd729",
      name: "medium",
      $figmaStyleReferences: {},
      selectedTokenSets: {
        "primitives/modes/size/medium": TokenSetStatus.SOURCE,
        "primitives/modes/size/global": TokenSetStatus.ENABLED,
        "primitives/modes/typography/size/medium": TokenSetStatus.ENABLED
      },
      $figmaCollectionId: "VariableCollectionId:36248:20757",
      $figmaModeId: "41630:1",
      group: "Size"
    },
    {
      id: "d49b9eebeb48a4f165a74b7261733d0a73370f0e",
      name: "large",
      $figmaStyleReferences: {},
      selectedTokenSets: {
        "primitives/modes/size/large": TokenSetStatus.SOURCE,
        "primitives/modes/size/global": TokenSetStatus.ENABLED,
        "primitives/modes/typography/size/large": TokenSetStatus.ENABLED
      },
      $figmaCollectionId: "VariableCollectionId:36248:20757",
      $figmaModeId: "41630:2",
      group: "Size"
    },
    {
      id: "fb11567729c298ca37c9da4e3a27716a23480824",
      name: "small",
      $figmaStyleReferences: {},
      selectedTokenSets: {
        "primitives/modes/size/small": TokenSetStatus.SOURCE,
        "primitives/modes/size/global": TokenSetStatus.ENABLED,
        "primitives/modes/typography/size/small": TokenSetStatus.ENABLED
      },
      $figmaCollectionId: "VariableCollectionId:36248:20757",
      $figmaModeId: "41630:3",
      group: "Size"
    }
  ];
}
var colorSchemeDefaults = {
  light: {
    name: "Light",
    selectedTokenSets: {},
    id: "0daa3ca0b427b9349da7e7dc00101b5668972926",
    $figmaCollectionId: "VariableCollectionId:34811:5472",
    $figmaModeId: "34811:0"
  },
  dark: {
    name: "Dark",
    selectedTokenSets: {},
    id: "9ebd8aed52afbffc17e2666e8b4653a53498b257",
    $figmaCollectionId: "VariableCollectionId:34811:5472",
    $figmaModeId: "34811:1"
  },
  contrast: {
    name: "Contrast",
    selectedTokenSets: {},
    id: "9ebd8aed52afbffc17e2666e8b4653a53498b123",
    $figmaCollectionId: "VariableCollectionId:34811:5472",
    $figmaModeId: "34811:2"
  }
};
function generateColorSchemesGroup(colorSchemes, themes) {
  return colorSchemes.map(
    (scheme) => ({
      ...colorSchemeDefaults[scheme],
      selectedTokenSets: Object.fromEntries([
        ...themes.map((theme) => [`primitives/modes/color-scheme/${scheme}/${theme}`, TokenSetStatus.ENABLED])
      ]),
      group: "Color scheme"
    })
  );
}
async function generateThemesGroup(themes) {
  return Promise.all(
    themes.map(
      async (theme, index) => ({
        id: await createHash(theme),
        $figmaCollectionId: "VariableCollectionId:36528:61712",
        $figmaModeId: `40960:${index + 6}`,
        // Start on 6 in Token Studio and Community file for some reason
        name: theme,
        selectedTokenSets: {
          [`themes/${theme}`]: TokenSetStatus.ENABLED
        },
        group: "Theme"
      })
    )
  );
}
function generateSemanticGroup() {
  return {
    id: "541629445ef90ad5363f9e88f52a1ccb617e6f84",
    name: "Semantic",
    selectedTokenSets: {
      "semantic/style": TokenSetStatus.ENABLED,
      "semantic/color": TokenSetStatus.ENABLED,
      "primitives/globals": TokenSetStatus.SOURCE
    },
    $figmaCollectionId: "VariableCollectionId:34811:5976",
    $figmaModeId: "34811:5",
    group: "Semantic"
  };
}
async function generateColorGroup(group, colors) {
  return Promise.all(
    Object.entries(colors[group]).map(
      async ([color]) => ({
        id: await createHash(`${group}-${color}`),
        name: color,
        selectedTokenSets: {
          [`semantic/modes/${group}-color/${color}`]: TokenSetStatus.ENABLED
        },
        group: `${capitalize(group)} color`
      })
    )
  );
}
function generateTypographyGroup(themes) {
  return [
    {
      id: "368d753fcac4455f289500eaa42e70dc0a03522f",
      $figmaCollectionId: "VariableCollectionId:36248:20769",
      $figmaModeId: "36248:2",
      name: "Primary",
      selectedTokenSets: Object.fromEntries(
        themes.map((theme) => [`primitives/modes/typography/primary/${theme}`, TokenSetStatus.ENABLED])
      ),
      group: "Typography"
    },
    {
      id: "264b8bd1d40b364e1ea3acf09e49795ddd4c513c",
      $figmaCollectionId: "VariableCollectionId:36248:20769",
      $figmaModeId: "36248:3",
      name: "Secondary",
      selectedTokenSets: Object.fromEntries(
        themes.map((theme) => [`primitives/modes/typography/secondary/${theme}`, TokenSetStatus.ENABLED])
      ),
      group: "Typography"
    }
  ];
}

// src/tokens/process/output/theme.ts
import pc2 from "picocolors";
import * as R9 from "ramda";

// package.json
var package_default = {
  name: "@digdir/designsystemet",
  version: "1.7.1",
  description: "CLI for Designsystemet",
  author: "Designsystemet team",
  engines: {
    node: ">=20 <25"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/digdir/designsystemet.git"
  },
  homepage: "https://github.com/digdir/designsystemet/tree/main/packages/cli",
  license: "MIT",
  type: "module",
  main: "./dist/src/index.js",
  files: [
    "./dist/**",
    "./configs/**"
  ],
  bin: "dist/bin/designsystemet.js",
  exports: {
    ".": {
      import: "./dist/src/index.js"
    },
    "./color": {
      import: "./dist/src/colors/index.js"
    },
    "./tokens": {
      import: "./dist/src/tokens/index.js"
    },
    "./types": {
      import: "./dist/src/types.js"
    }
  },
  publishConfig: {
    access: "public"
  },
  scripts: {
    designsystemet: "tsx ./bin/designsystemet.ts",
    "designsystemet:inspect": "tsx --inspect-brk ./bin/designsystemet.ts",
    build: "tsup && pnpm build:types && pnpm build:json-schema",
    "build:types": "tsc --emitDeclarationOnly --declaration",
    "build:json-schema": "tsx ./src/scripts/createJsonSchema.ts",
    types: "tsc --noEmit",
    "test:tokens-create-options": 'pnpm run designsystemet tokens create -m dominant:"#007682" -n "#003333" -b 99 -o ./temp/options/design-tokens --theme options --clean',
    "test:tokens-create-config": "pnpm run designsystemet tokens create --config ./configs/test-tokens.config.json",
    "test:tokens-build": "pnpm run designsystemet tokens build -t ./temp/options/design-tokens -o ./temp/options/build --clean",
    "test:tokens-build-tailwind": "pnpm run designsystemet tokens build -t ./temp/options/design-tokens -o ./temp/options/build --clean --experimental-tailwind",
    "test:tokens-build-config": "pnpm run designsystemet tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean",
    "test:tokens-build-config:inspect": "pnpm run designsystemet:inspect tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean",
    "test:tokens-build-config-tailwind": "pnpm run designsystemet tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean --experimental-tailwind",
    "test:tokens-create-and-build-options": "pnpm test:tokens-create-options && pnpm test:tokens-build",
    "test:tokens-create-and-build-config": "pnpm test:tokens-create-config && pnpm test:tokens-build-config",
    test: "node -v && pnpm test:tokens-create-and-build-options && pnpm test:tokens-create-and-build-config",
    "digdir:tokens-build": "pnpm run designsystemet tokens build -t ../../internal/design-tokens -o ../../packages/theme/brand --clean --experimental-tailwind",
    "digdir:tokens-create": "pnpm run designsystemet tokens create --config ./configs/digdir.config.json",
    "update:template": "tsx ./src/scripts/update-template.ts",
    "update:preview-tokens": "tsx ./src/scripts/update-preview-tokens.ts",
    "update:theme-digdir": "pnpm digdir:tokens-create && tsx ./src/scripts/update-design-tokens.ts && pnpm digdir:tokens-build",
    verify: "pnpm test && pnpm update:template && pnpm update:theme-digdir && pnpm build:tokens"
  },
  dependencies: {
    "@commander-js/extra-typings": "^14.0.0",
    "@tokens-studio/sd-transforms": "1.3.0",
    "apca-w3": "^0.1.9",
    "change-case": "^5.4.4",
    "chroma-js": "^3.1.2",
    "colorjs.io": "^0.6.0-alpha.1",
    commander: "^14.0.1",
    "fast-glob": "^3.3.3",
    hsluv: "^1.0.1",
    "object-hash": "^3.0.0",
    picocolors: "^1.1.1",
    postcss: "^8.5.6",
    ramda: "^0.32.0",
    "style-dictionary": "^5.1.1",
    zod: "^4.1.12",
    "zod-validation-error": "^4.0.2"
  },
  devDependencies: {
    "@tokens-studio/types": "0.5.2",
    "@types/apca-w3": "^0.1.3",
    "@types/chroma-js": "^3.1.1",
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^22.18.11",
    "@types/object-hash": "^3.0.6",
    "@types/ramda": "^0.31.1",
    "fs-extra": "^11.3.2",
    tslib: "^2.8.1",
    tsup: "^8.5.0",
    tsx: "^4.20.6",
    typescript: "^5.9.3"
  }
};

// src/tokens/utils.ts
import * as R8 from "ramda";

// src/tokens/types.ts
var colorCategories = {
  main: "main",
  support: "support"
};

// src/tokens/utils.ts
var mapToLowerCase = R8.map(R8.toLower);
var hasAnyTruth = R8.any(R8.equals(true));
var getType = (token) => (token.$type ?? token.type) || "";
var getValue = (token) => token.$value ?? token.value;
var typeEquals = R8.curry(
  (types, token) => {
    if (R8.isNil(token)) {
      return false;
    }
    return R8.includes(R8.toLower(getType(token)), R8.map(R8.toLower, Array.isArray(types) ? types : [types]));
  }
);
var pathStartsWithOneOf = R8.curry(
  (paths, token) => {
    if (R8.isNil(token)) {
      return false;
    }
    const tokenPath = mapToLowerCase(token.path);
    const matchPathsStartingWith = R8.map((pathOrString) => {
      const path2 = typeof pathOrString === "string" ? [pathOrString] : pathOrString;
      return R8.startsWith(mapToLowerCase(path2), tokenPath);
    }, paths);
    return hasAnyTruth(matchPathsStartingWith);
  }
);
function isSemanticToken(token) {
  return token.filePath.includes("semantic/");
}
function isSemanticColorToken(token, color) {
  return token.filePath.includes("semantic/") && R8.startsWith(["color", color], token.path);
}
function isGlobalColorToken(token) {
  return typeEquals("color", token) && pathStartsWithOneOf(["global"], token);
}
function isColorCategoryToken(token, category) {
  if (!category) {
    return Object.keys(colorCategories).some(
      (colorCategory2) => isColorCategoryToken(token, colorCategory2)
    );
  }
  return R8.startsWith(["color", category], token.path);
}
var isDigit = (s) => /^\d+$/.test(s);
function traverseObj(obj, fn) {
  for (const key in obj) {
    const prop3 = obj[key];
    if (prop3 != null) {
      fn.apply(null, [obj, key, prop3]);
      if (typeof prop3 === "object") {
        traverseObj(prop3, fn);
      }
    }
  }
  return obj;
}
function inlineTokens(shouldInline, tokens) {
  const [inlineableTokens, otherTokens] = R8.partition(shouldInline, tokens);
  return otherTokens.map((token) => {
    let transformed = getValue(token.original);
    for (const ref of inlineableTokens) {
      const refName = ref.path.join(".");
      if (typeof transformed === "string") {
        transformed = transformed.replaceAll(`{${refName}}`, getValue(ref.original));
      }
    }
    const tokenWithInlinedRefs = R8.set(R8.lensPath(["original", "$value"]), transformed, token);
    return tokenWithInlinedRefs;
  });
}
var sizeMap = {
  xsmall: "xs",
  small: "sm",
  medium: "md",
  large: "lg",
  xlarge: "xl"
};
function shortSizeName(size2) {
  return sizeMap[size2] ?? size2;
}
var sizeComparator = (size2) => {
  const sortIndex = Object.entries(sizeMap).findIndex(([key, val]) => key === size2 || val === size2);
  return sortIndex ?? 0;
};
function orderBySize(sizes) {
  return R8.sortBy(sizeComparator, sizes);
}

// src/tokens/process/output/theme.ts
var defaultFileHeader = `build: v${package_default.version}`;
var getFileNameWithoutExtension = (path2) => {
  const pathSegments = path2.split("/");
  return pathSegments[pathSegments.length - 1].split(".").slice(0, -1).join(".");
};
var createThemeCSSFiles = ({
  processedBuilds,
  fileHeader = defaultFileHeader
}) => {
  const groupedByTheme = {};
  for (const [_, buildResults] of Object.entries(processedBuilds)) {
    for (const buildResult of buildResults) {
      const themeName = buildResult.permutation.theme;
      const newOutputs = buildResult.formatted;
      if (R9.isNotEmpty(newOutputs)) {
        const currentOutputs = groupedByTheme[themeName] ?? [];
        groupedByTheme[themeName] = R9.concat(currentOutputs, newOutputs);
      }
    }
  }
  const sortOrder = [
    "size-mode/",
    "type-scale",
    "color-scheme/light",
    "typography/secondary",
    "size",
    "semantic",
    "color-scheme/dark",
    "color-scheme/contrast",
    "typography/primary",
    "color/"
  ];
  const sortByDefinedOrder = R9.sortBy((file) => {
    const filePath = file.destination || "";
    const sortIndex = sortOrder.findIndex((sortElement) => {
      if (sortElement.endsWith("/")) {
        return filePath.includes(sortElement);
      }
      return filePath.includes(`${sortElement}.css`);
    });
    if (sortIndex === -1) {
      console.error(
        pc2.yellow(`WARNING: CSS section does not have a defined sort order: ${filePath.replace(".css", "")}`)
      );
      console.log(
        pc2.dim(
          `
The section will currently be added to the end of the entry file, but the exact
order may change due to nondeterminism.`.trim()
        )
      );
      return Infinity;
    }
    return sortIndex;
  });
  const header = `@charset "UTF-8";
/*
${fileHeader}
*/

`;
  const sortAlphabetically = R9.sort(R9.ascend((x) => x.destination || ""));
  const sortBySize = R9.sortBy(
    R9.pipe((s) => getFileNameWithoutExtension(s.destination ?? ""), sizeComparator)
  );
  const pickOutputs = R9.map(R9.view(R9.lensProp("output")));
  const themeCSSFile = R9.pipe(
    sortAlphabetically,
    sortBySize,
    sortByDefinedOrder,
    pickOutputs,
    R9.join("\n"),
    (content) => header + content
  );
  const themeCSSFiles = Object.entries(groupedByTheme).map(([theme, files]) => ({
    destination: `${theme}.css`,
    output: themeCSSFile(files)
  }));
  return themeCSSFiles;
};

// src/tokens/process/platform.ts
import pc4 from "picocolors";
import * as R23 from "ramda";
import StyleDictionary2 from "style-dictionary";

// src/tokens/process/configs.ts
import { register } from "@tokens-studio/sd-transforms";
import * as R22 from "ramda";
import StyleDictionary from "style-dictionary";

// src/tokens/process/configs/color.ts
import * as R17 from "ramda";

// src/tokens/process/formats/css/color.ts
import * as R10 from "ramda";
import { createPropertyFormatter } from "style-dictionary/utils";
var prefersColorScheme = (colorScheme2, content) => `
@media (prefers-color-scheme: ${colorScheme2}) {
  [data-color-scheme="auto"] ${content}
}
`;
var colorScheme = {
  name: "ds/css-colorscheme",
  format: async ({ dictionary, options, platform }) => {
    const { allTokens } = dictionary;
    const { outputReferences, usesDtcg } = options;
    const { selector, colorScheme: colorScheme2, layer } = platform;
    const colorScheme_ = colorScheme2;
    const format = createPropertyFormatter({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const colorSchemeProperty = colorScheme_ === "dark" || colorScheme_ === "light" ? `
  color-scheme: ${colorScheme_};
` : "";
    const filteredAllTokens = allTokens.filter(
      R10.allPass([
        R10.anyPass([
          // Include semantic tokens in the output
          isSemanticToken,
          // Include global color tokens
          isGlobalColorToken
        ]),
        // Don't include color category tokens -- they are exported separately
        (t) => !isColorCategoryToken(t)
      ])
    );
    const formattedMap = filteredAllTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    const formattedTokens = formattedMap.map(R10.view(R10.lensProp("formatted"))).join("\n");
    const content = `{
${formattedTokens}
${colorSchemeProperty}}
`;
    const autoSelectorContent = ["light", "dark"].includes(colorScheme_) ? prefersColorScheme(colorScheme_, content) : "";
    const body = R10.isNotNil(layer) ? `@layer ${layer} {
${selector} ${content} ${autoSelectorContent}
}
` : `${selector} ${content} ${autoSelectorContent}
`;
    return body;
  }
};
var colorCategory = {
  name: "ds/css-colorcategory",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = R10.compose(
      createPropertyFormatter({
        outputReferences,
        dictionary,
        format: "css",
        usesDtcg
      }),
      (token) => ({
        ...token,
        name: token.name.replace(/color-\w+-/, "color-"),
        original: {
          ...token.original,
          $value: new RegExp(`color-(${colorCategories.main}|${colorCategories.support})-`).test(token.name) ? token.original.$value : `{${token.path.join(".")}}`
        }
      })
    );
    const formattedMap = dictionary.allTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R10.view(R10.lensProp("formatted"))).join("\n");
    const content = `{
${formattedTokens}
}
`;
    const body = R10.isNotNil(layer) ? `@layer ${layer} {
${selector} ${content}
}
` : `${selector} ${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/semantic.ts
import * as R12 from "ramda";
import { createPropertyFormatter as createPropertyFormatter3 } from "style-dictionary/utils";

// src/tokens/process/formats/css/size.ts
import * as R11 from "ramda";
import { createPropertyFormatter as createPropertyFormatter2 } from "style-dictionary/utils";
var isNumericBorderRadiusToken = (t) => t.path[0] === "border-radius" && isDigit(t.path[1]);
var isNumericSizeToken = (t) => pathStartsWithOneOf(["size"], t) && isDigit(t.path[1]);
var isSizeToken = (t) => pathStartsWithOneOf(["size"], t);
var isInlineTokens = R11.anyPass([isNumericBorderRadiusToken, isNumericSizeToken, isSizeToken]);
var overrideSizingFormula = (format, token) => {
  const [name, value] = format(token).replace(/;$/, "").split(": ");
  let calc;
  let round;
  if (token.path[1] === "unit") {
    calc = `calc(1rem * ${value})`;
  } else if (value.startsWith("floor")) {
    calc = value.replace(/^floor\((.*)\)$/, "calc($1)");
    round = `round(down, ${calc}, 1px)`;
  } else {
    calc = value.includes("*") ? `calc(${value})` : value;
  }
  return {
    name,
    round: round ?? calc,
    calc
  };
};
var formatSizingTokens = (format, tokens) => R11.reduce(
  (acc, token) => {
    const { round, calc, name } = overrideSizingFormula(format, token);
    return {
      tokens: [...acc.tokens, token],
      round: [...acc.round, `${name}: ${round};`],
      calc: [...acc.calc, `${name}: ${calc};`]
    };
  },
  { tokens: [], round: [], calc: [] },
  tokens
);
var sizingTemplate = ({ round, calc }) => {
  const usesRounding = round.filter((val, i) => val !== calc[i]);
  return `
${calc.join("\n")}

  @supports (width: round(down, .1em, 1px)) {
  ${usesRounding.join("\n  ")}
  }`;
};
var size = {
  name: "ds/css-size",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter2({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const tokens = inlineTokens(isInlineTokens, dictionary.allTokens);
    const filteredTokens = R11.reject((token) => R11.equals(["_size", "mode-font-size"], token.path), tokens);
    const [sizingTokens, restTokens] = R11.partition(
      (t) => pathStartsWithOneOf(["_size"], t) && (isDigit(t.path[1]) || t.path[1] === "unit"),
      filteredTokens
    );
    const formattedSizingTokens = formatSizingTokens(format, sizingTokens);
    const formattedMap = restTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    const formattedSizingMap = formattedSizingTokens.round.map((t, i) => ({
      token: formattedSizingTokens.tokens[i],
      formatted: t
    }));
    buildOptions.buildTokenFormats[destination] = [...formattedMap, ...formattedSizingMap];
    const formattedTokens = [formattedMap.map(R11.prop("formatted")).join("\n"), sizingTemplate(formattedSizingTokens)];
    const content = `${selector} {
${formattedTokens.join("\n")}
}
`;
    const body = R11.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/semantic.ts
var semantic = {
  name: "ds/css-semantic",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter3({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const tokens = inlineTokens(isInlineTokens, dictionary.allTokens);
    const formattedMap = tokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R12.prop("formatted")).join("\n");
    const content = `${selector} {
${formattedTokens}
}
`;
    const body = R12.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/size-mode.ts
import * as R14 from "ramda";
import { createPropertyFormatter as createPropertyFormatter4 } from "style-dictionary/utils";

// src/tokens/process/transformers.ts
import { checkAndEvaluateMath } from "@tokens-studio/sd-transforms";
import * as R13 from "ramda";
var isPx = R13.test(/\b\d+px\b/g);
var sizeRem = {
  name: "ds/size/toRem",
  type: "value",
  transitive: true,
  filter: (token) => {
    const hasWantedType = typeEquals(["dimension", "fontsize"], token);
    const hasWantedPath = pathStartsWithOneOf([
      "border-radius",
      "font-size"
      /*, ['_size', 'mode-font-size']*/
    ], token);
    return hasWantedType && hasWantedPath;
  },
  transform: (token, config) => {
    const value = getValue(token);
    if (isPx(value)) {
      const baseFont = config.basePxFontSize || 16;
      const size2 = parseInt(value, 10);
      if (size2 === 0) {
        return "0";
      }
      return `${size2 / baseFont}rem`;
    }
    return value;
  }
};
var typographyName = {
  name: "name/typography",
  type: "name",
  transitive: true,
  // expanded tokens have different type so we match on path instead
  filter: (token) => pathStartsWithOneOf(["typography"], token),
  transform: (token) => {
    return token.name.replace("-typography", "");
  }
};
var resolveMath = {
  name: "ds/resolveMath",
  type: "value",
  transitive: true,
  filter: (token) => {
    const isValidValue = ["string", "object"].includes(typeof getValue(token));
    const isTokenOfInterest = !pathStartsWithOneOf(["border-radius"], token);
    return isValidValue && isTokenOfInterest;
  },
  transform: (token, platformCfg) => checkAndEvaluateMath(token, platformCfg.mathFractionDigits)
};
var unitless = {
  name: "ds/unitless",
  type: "value",
  transitive: true,
  filter: (token) => pathStartsWithOneOf(["size", "_size"], token),
  transform: (token) => parseInt(getValue(token), 10)
};

// src/tokens/process/configs/shared.ts
var prefix = "ds";
var basePxFontSize = 16;
var dsTransformers = [
  "name/kebab",
  resolveMath.name,
  "ts/size/px",
  sizeRem.name,
  unitless.name,
  "ts/typography/fontWeight",
  typographyName.name,
  "ts/color/modifiers",
  "ts/color/css/hexrgba",
  "ts/size/lineheight",
  "shadow/css/shorthand"
];

// src/tokens/process/formats/css/size-mode.ts
var formatBaseSizeToken = (size2) => (token) => ({
  ...token,
  originalName: token.name,
  name: `${token.name}--${shortSizeName(size2)}`,
  $value: token.$value / basePxFontSize
});
var sizeMode = {
  name: "ds/css-size-mode",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer, size: size2 } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter4({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const sizeSpecificTokens = dictionary.allTokens.map(formatBaseSizeToken(size2));
    const sizeSpecificVariables = sizeSpecificTokens.map(format).join("\n");
    const formattedMap = sizeSpecificTokens.map((token) => ({
      token,
      formatted: format({
        ...token,
        // Remove the `--<size>` suffix for the token listing, since that is the only token we actually use
        name: token.originalName
      })
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const content = `${selector} /* ${size2} */ {
${sizeSpecificVariables}
}`;
    const body = wrapInLayer(content, layer);
    const sizes = orderBySize(buildOptions?.sizeModes ?? []).map(shortSizeName);
    const defaultSize = shortSizeName(buildOptions?.defaultSize ?? "");
    const sizingToggles = `:root, [data-size] {
  --ds-size: var(--ds-size--${defaultSize});
${sizes.map((size3) => `  --ds-size--${size3}: var(--ds-size,);`).join("\n")}
  --ds-size-mode-font-size:
${sizes.map((size3) => `    var(--ds-size--${size3}, var(--ds-size-mode-font-size--${size3}))`).join("\n")};
}`;
    const sizingHelpers = sizes.map((size3) => `[data-size='${size3}'] { --ds-size: var(--ds-size--${size3}); }`).join("\n");
    const sharedContent = `${sizingToggles}

${sizingHelpers}`;
    const sharedBody = shortSizeName(size2) === R14.last(sizes) ? `
${wrapInLayer(sharedContent, layer)}` : "";
    return body + sharedBody;
  }
};
function wrapInLayer(content, layer) {
  return R14.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
}

// src/tokens/process/formats/css/typography.ts
import * as R15 from "ramda";
import { createPropertyFormatter as createPropertyFormatter5 } from "style-dictionary/utils";
var typographyFontFamilyPredicate = R15.allPass([
  R15.pathSatisfies(R15.includes("typography"), ["path"]),
  R15.pathSatisfies(R15.includes("fontFamily"), ["path"])
]);
var typography = {
  name: "ds/css-typography",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter5({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const filteredTokens = R15.reject(typographyFontFamilyPredicate, dictionary.allTokens);
    const formattedMap = filteredTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R15.view(R15.lensProp("formatted"))).join("\n");
    const content = selector ? `${selector} {
${formattedTokens}
}` : formattedTokens;
    const body = R15.isNotNil(layer) ? `@layer ${layer} {
${content}
}` : content;
    return body;
  }
};

// src/tokens/process/formats/css/type-scale.ts
import * as R16 from "ramda";
import { createPropertyFormatter as createPropertyFormatter6 } from "style-dictionary/utils";
var isTypographyFontFamilyToken = R16.allPass([
  R16.pathSatisfies(R16.includes("typography"), ["path"]),
  R16.pathSatisfies(R16.includes("fontFamily"), ["path"])
]);
var formatTypographySizeToken = (format, token) => {
  const [name, value] = format(token).replace(/;$/, "").split(": ");
  let calc;
  let round;
  if (R16.startsWith(["font-size"], token.path)) {
    calc = `calc(${value} * var(--_ds-font-size-factor))`;
    round = `round(${calc}, 1px)`;
  } else {
    calc = value;
  }
  return { name, calc, round: round ?? calc };
};
var formatTypographySizeTokens = (format, tokens) => R16.reduce(
  (acc, token) => {
    const { name, calc, round } = formatTypographySizeToken(format, token);
    acc.tokens.push(token);
    acc.calc.push(`${name}: ${calc};`);
    acc.round.push(`${name}: ${round};`);
    return acc;
  },
  { tokens: [], calc: [], round: [] },
  tokens
);
var typeScale = {
  name: "ds/css-type-scale",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter6({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const filteredTokens = R16.reject(R16.anyPass([isTypographyFontFamilyToken]), dictionary.allTokens);
    const formattedTokens = formatTypographySizeTokens(format, filteredTokens);
    const formattedMap = formattedTokens.round.map((t, i) => ({
      token: formattedTokens.tokens[i],
      formatted: t
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const sizeFactor = `  --_ds-font-size-factor: calc(var(--ds-size-mode-font-size) / (var(--ds-size-base) / ${basePxFontSize}));`;
    const content = `${selector} {
${sizeFactor}${sizingTemplate(formattedTokens)}
}`;
    const body = R16.isNotNil(layer) ? `@layer ${layer} {
${content}
}` : content;
    return body;
  }
};

// src/tokens/process/formats/css.ts
var formats = {
  colorScheme,
  colorCategory,
  semantic,
  sizeMode,
  size,
  typography,
  typeScale
};

// src/tokens/process/configs/color.ts
var colorSchemeVariables = ({ "color-scheme": colorScheme2 = "light", theme }) => {
  const selector = `${colorScheme2 === "light" ? ":root, " : ""}[data-color-scheme="${colorScheme2}"]`;
  const layer = `ds.theme.color-scheme.${colorScheme2}`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        colorScheme: colorScheme2,
        theme,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `color-scheme/${colorScheme2}.css`,
            format: formats.colorScheme.name,
            filter: (token) => typeEquals("color", token) && !R17.startsWith(["global"], token.path)
          }
        ],
        options: {
          outputReferences: false
        }
      }
    }
  };
};
var colorCategoryVariables = (opts) => ({ "color-scheme": colorScheme2, theme, ...permutation }) => {
  const category = opts.category;
  const color = category === "builtin" ? opts.color : permutation[`${category}-color`];
  if (!color) {
    throw new Error(
      category === "builtin" ? `Missing color for built-in color ${opts.color}` : `Missing color for category ${category}`
    );
  }
  const layer = `ds.theme.color`;
  const isRootColor = color === buildOptions?.defaultColor;
  const selector = isRootColor ? `:root, [data-color-scheme], [data-color="${color}"]` : `[data-color="${color}"], [data-color-scheme][data-color="${color}"]`;
  const config = {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        colorScheme: colorScheme2,
        theme,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `color/${color}.css`,
            format: formats.colorCategory.name,
            filter: (token) => category === "builtin" ? isSemanticColorToken(token, color) : isColorCategoryToken(token, category)
          }
        ],
        options: {
          outputReferences: true
        }
      }
    }
  };
  return config;
};

// src/tokens/process/configs/semantic.ts
import * as R18 from "ramda";
import { outputReferencesFilter } from "style-dictionary/utils";
var semanticVariables = ({ theme }) => {
  const selector = `:root`;
  const layer = `ds.theme.semantic`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `semantic.css`,
            format: formats.semantic.name,
            filter: (token) => {
              const isUwantedToken = R18.anyPass([R18.includes("primitives/global")])(token.filePath);
              const isPrivateToken = R18.includes("_", token.path);
              const unwantedPaths = pathStartsWithOneOf(
                ["size", "_size", "font-size", "line-height", "letter-spacing"],
                token
              );
              const unwantedTypes = typeEquals(["color", "fontWeight", "fontFamily", "typography"], token);
              const unwantedTokens = !(unwantedPaths || unwantedTypes || isPrivateToken || isUwantedToken);
              return unwantedTokens;
            }
          }
        ],
        options: {
          outputReferences: (token, options) => {
            const include = pathStartsWithOneOf(["border-radius"], token);
            return include && outputReferencesFilter(token, options);
          }
        }
      }
    }
  };
};

// src/tokens/process/configs/size.ts
import * as R19 from "ramda";
import { outputReferencesFilter as outputReferencesFilter2 } from "style-dictionary/utils";
var sizeVariables = ({ theme }) => {
  const selector = `:root, [data-size]`;
  const layer = `ds.theme.size`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `size.css`,
            format: formats.size.name,
            filter: (token) => {
              const isUwantedToken = R19.anyPass([R19.includes("primitives/global")])(token.filePath);
              const isPrivateToken = R19.includes("_", token.path);
              return pathStartsWithOneOf(["size", "_size"], token) && !(isUwantedToken || isPrivateToken);
            }
          }
        ],
        options: {
          outputReferences: (token, options) => {
            const isWantedSize = pathStartsWithOneOf(["size", "_size"], token) && (isDigit(token.path[1]) || token.path[1] === "unit");
            return isWantedSize && outputReferencesFilter2(token, options);
          }
        }
      }
    }
  };
};

// src/tokens/process/configs/size-mode.ts
import * as R20 from "ramda";
var sizeModeVariables = ({ theme, size: size2 }) => {
  const selector = `:root`;
  const layer = `ds.theme.size-mode`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        size: size2,
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `size-mode/${size2}.css`,
            format: formats.sizeMode.name,
            filter: (token) => {
              return R20.equals(["_size", "mode-font-size"], token.path);
            }
          }
        ]
      }
    }
  };
};

// src/tokens/process/configs/type-scale.ts
var typeScaleVariables = ({ theme }) => {
  const selector = ":root, [data-size]";
  const layer = `ds.theme.type-scale`;
  return {
    usesDtcg: true,
    preprocessors: ["tokens-studio"],
    expand: {
      include: ["typography"]
    },
    platforms: {
      css: {
        prefix,
        selector,
        layer,
        buildPath: `${theme}/`,
        basePxFontSize,
        transforms: [
          "name/kebab",
          "ts/size/px",
          sizeRem.name,
          "ts/size/lineheight",
          "ts/typography/fontWeight",
          typographyName.name
        ],
        files: [
          {
            destination: `type-scale.css`,
            format: formats.typeScale.name,
            filter: (token) => {
              const included = typeEquals(["typography", "dimension", "fontsize"], token);
              if (/primitives\/modes\/typography\/(primary|secondary)/.test(token.filePath)) return false;
              return included && !pathStartsWithOneOf(["spacing", "sizing", "size", "border-width", "border-radius"], token) && (pathStartsWithOneOf(["font-size"], token) || token.path.includes("fontSize"));
            }
          }
        ],
        options: {
          outputReferences: (token) => pathStartsWithOneOf(["typography"], token) && token.path.includes("fontSize")
        }
      }
    }
  };
};

// src/tokens/process/configs/typography.ts
import { expandTypesMap } from "@tokens-studio/sd-transforms";
var typographyVariables = ({ theme, typography: typography2 }) => {
  const selector = `${typography2 === "primary" ? ":root, " : ""}[data-typography="${typography2}"]`;
  const layer = `ds.theme.typography.${typography2}`;
  return {
    usesDtcg: true,
    preprocessors: ["tokens-studio"],
    expand: {
      include: ["typography"],
      typesMap: { ...expandTypesMap, typography: { ...expandTypesMap.typography, letterSpacing: "dimension" } }
    },
    platforms: {
      css: {
        prefix,
        typography: typography2,
        selector,
        layer,
        buildPath: `${theme}/`,
        basePxFontSize,
        transforms: [
          "name/kebab",
          "ts/size/px",
          sizeRem.name,
          "ts/size/lineheight",
          "ts/typography/fontWeight",
          "ts/size/css/letterspacing",
          typographyName.name
        ],
        files: [
          {
            destination: `typography/${typography2}.css`,
            format: formats.typography.name,
            filter: (token) => {
              const included = typeEquals(["fontweight", "fontFamily", "lineHeight", "dimension"], token);
              if (/primitives\/modes\/typography\/(primary|secondary)/.test(token.filePath)) return false;
              return included && !pathStartsWithOneOf(["spacing", "sizing", "size", "_size", "border-width", "border-radius"], token) && !(pathStartsWithOneOf(["typography"], token) && token.path.includes("fontSize"));
            }
          }
        ]
      }
    }
  };
};

// src/tokens/process/utils/getMultidimensionalThemes.ts
import { kebabCase } from "change-case";
import pc3 from "picocolors";
import * as R21 from "ramda";
var getMultidimensionalThemes = (processed$themes, dimensions) => {
  const verboseLogging = buildOptions?.verbose;
  const grouped$themes = groupThemes(processed$themes);
  const permutations = permutateThemes(grouped$themes);
  const ALL_DEPENDENT_ON = ["theme"];
  const keys2 = R21.keys(grouped$themes);
  const nonDependentKeys = keys2.filter((x) => ![...ALL_DEPENDENT_ON, ...dimensions].includes(x));
  if (verboseLogging) {
    console.log(pc3.cyan(`\u{1F50E} Finding theme permutations for ${dimensions}`));
    console.log(pc3.cyan(`   (ignoring permutations for ${nonDependentKeys})`));
  }
  return permutations.filter((val) => {
    const filters = nonDependentKeys.map((x) => val.permutation[x] === grouped$themes[x][0].name);
    return filters.every((x) => x);
  });
};
var processed = Symbol("Type brand for ProcessedThemeObject");
function isProcessed(theme) {
  return Boolean(theme[processed]);
}
function processThemeObject(theme) {
  if (isProcessed(theme)) {
    return theme;
  }
  const result = { ...theme, [processed]: true };
  if (result.group) {
    result.group = kebabCase(result.group);
  }
  result.name = kebabCase(result.name);
  return result;
}
function groupThemes(themes) {
  const groups = {};
  for (const theme of themes) {
    if (theme.group) {
      const groupKey = theme.group;
      groups[groupKey] = [...groups[groupKey] ?? [], theme];
    } else {
      throw new Error(
        `Theme ${theme.name} does not have a group property, which is required for multi-dimensional theming.`
      );
    }
  }
  return groups;
}
var hasUnknownProps = R21.pipe(R21.values, R21.none(R21.equals("unknown")), R21.not);
function permutateThemes(groups) {
  const separator = "_";
  const permutations = cartesian(Object.values(groups));
  const permutatedThemes = permutations.map((perm) => {
    const permutatedTheme = perm.reduce(
      (acc, theme) => {
        const { group, name, selectedTokenSets } = theme;
        let updatedPermutation = acc.permutation;
        if (group) {
          const groupProp = R21.lensProp(group);
          updatedPermutation = R21.set(groupProp, name, updatedPermutation);
        }
        const updatedName = `${String(acc.name)}${acc ? separator : ""}${name}`;
        const sets = [...acc.selectedTokenSets, ...filterTokenSets(selectedTokenSets)];
        return {
          permutation: updatedPermutation,
          name: updatedName,
          selectedTokenSets: sets
        };
      },
      {
        name: "",
        selectedTokenSets: [],
        permutation: {
          "color-scheme": "unknown",
          "main-color": "unknown",
          "support-color": "unknown",
          theme: "unknown",
          semantic: "unknown",
          size: "unknown",
          typography: "unknown"
        }
      }
    );
    if (hasUnknownProps(permutatedTheme)) {
      throw Error(`Theme ${permutatedTheme.name} has unknown props: ${JSON.stringify(permutatedTheme)}`);
    }
    const uniqueTokenSets = new Set(permutatedTheme.selectedTokenSets);
    return { ...permutatedTheme, selectedTokenSets: Array.from(uniqueTokenSets) };
  });
  return permutatedThemes;
}
function filterTokenSets(tokensets) {
  return Object.entries(tokensets).filter(([, val]) => val !== TokenSetStatus.DISABLED).sort((a, b) => {
    if (a[1] === TokenSetStatus.SOURCE && b[1] === TokenSetStatus.ENABLED) {
      return -1;
    }
    if (a[1] === TokenSetStatus.ENABLED && b[1] === TokenSetStatus.SOURCE) {
      return 1;
    }
    return 0;
  }).map((entry) => entry[0]);
}
function cartesian(a) {
  return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
}
var getCustomColors = (processed$themes, colorGroups) => processed$themes.filter((x) => {
  if (!x.group) {
    return false;
  }
  return colorGroups.includes(x.group);
}).map((x) => x.name);

// src/tokens/process/configs.ts
void register(StyleDictionary, { withSDBuiltins: false });
StyleDictionary.registerTransform(sizeRem);
StyleDictionary.registerTransform(typographyName);
StyleDictionary.registerTransform(resolveMath);
StyleDictionary.registerTransform(unitless);
for (const format of Object.values(formats)) {
  StyleDictionary.registerFormat(format);
}
var configs = {
  colorSchemeVariables,
  mainColorVariables: colorCategoryVariables({ category: "main" }),
  supportColorVariables: colorCategoryVariables({ category: "support" }),
  neutralColorVariables: colorCategoryVariables({ category: "builtin", color: "neutral" }),
  successColorVariables: colorCategoryVariables({ category: "builtin", color: "success" }),
  dangerColorVariables: colorCategoryVariables({ category: "builtin", color: "danger" }),
  warningColorVariables: colorCategoryVariables({ category: "builtin", color: "warning" }),
  infoColorVariables: colorCategoryVariables({ category: "builtin", color: "info" }),
  sizeModeVariables,
  sizeVariables,
  typographyVariables,
  typeScaleVariables,
  semanticVariables
};
var getConfigsForThemeDimensions = (getConfig, processed$themes, dimensions, options) => {
  const { tokensDir, tokenSets } = options;
  const permutations = getMultidimensionalThemes(processed$themes, dimensions);
  return permutations.flatMap(({ selectedTokenSets, permutation }) => {
    const tokenSource = { source: void 0, tokens: {} };
    if (tokenSets) {
      for (const tokenSet of selectedTokenSets) {
        const tokens = tokenSets.get(tokenSet);
        if (tokens) {
          const tokensWithFilePath = traverseObj(tokens, (obj) => {
            if (Object.hasOwn(obj, `$value`) && !obj.filePath) {
              obj.filePath = tokenSet;
            }
          });
          tokenSource.tokens = R22.mergeDeepRight(tokenSource.tokens, tokensWithFilePath);
        }
      }
    } else {
      tokenSource.source = selectedTokenSets.map((x) => `${tokensDir}/${x}.json`);
    }
    const configOrConfigs = getConfig(permutation);
    const configs_ = Array.isArray(configOrConfigs) ? configOrConfigs : [{ config: configOrConfigs }];
    const configs2 = configs_.map(({ config, permutationOverrides }) => {
      return {
        permutation: { ...permutation, ...permutationOverrides },
        config: {
          ...config,
          /** Use official W3C design token format
          @see https://v4.styledictionary.com/info/dtcg/
          @see https://design-tokens.github.io/community-group/format/ */
          usesDtcg: true,
          log: {
            ...config?.log,
            verbosity: buildOptions?.verbose ? "verbose" : "silent"
          },
          ...tokenSource
        }
      };
    });
    return configs2;
  }).sort();
};

// src/tokens/process/platform.ts
var initResult = {
  formatted: [],
  tokens: [],
  permutation: {
    "color-scheme": "",
    "main-color": "",
    "support-color": "",
    semantic: "",
    size: "",
    theme: "",
    typography: ""
  }
};
var buildOptions = {
  verbose: false,
  processed$themes: [],
  buildTokenFormats: {}
};
var sd = new StyleDictionary2();
var buildConfigs = {
  typography: { getConfig: configs.typographyVariables, dimensions: ["typography"] },
  sizeMode: { getConfig: configs.sizeModeVariables, dimensions: ["size"] },
  size: { getConfig: configs.sizeVariables, dimensions: ["semantic"] },
  typeScale: { getConfig: configs.typeScaleVariables, dimensions: ["semantic"] },
  "color-scheme": { getConfig: configs.colorSchemeVariables, dimensions: ["color-scheme"] },
  "main-color": { getConfig: configs.mainColorVariables, dimensions: ["main-color"] },
  "support-color": { getConfig: configs.supportColorVariables, dimensions: ["support-color"] },
  "neutral-color": {
    getConfig: configs.neutralColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - neutral`
  },
  "success-color": {
    getConfig: configs.successColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - success`
  },
  "danger-color": {
    getConfig: configs.dangerColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - danger`
  },
  "warning-color": {
    getConfig: configs.warningColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - warning`
  },
  "info-color": {
    getConfig: configs.infoColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - info`
  },
  semantic: { getConfig: configs.semanticVariables, dimensions: ["semantic"] }
};
async function processPlatform(options) {
  const { type, processed$themes } = options;
  const platform = "css";
  const tokenSets = type === "format" ? options.tokenSets : void 0;
  const tokensDir = type === "build" ? options.tokensDir : void 0;
  const UNSAFE_DEFAULT_COLOR = process.env.UNSAFE_DEFAULT_COLOR ?? "";
  if (UNSAFE_DEFAULT_COLOR) {
    console.warn(
      pc4.yellow(
        `
\u26A0\uFE0F UNSAFE_DEFAULT_COLOR is set to ${pc4.blue(UNSAFE_DEFAULT_COLOR)}. This will override the default color.`
      )
    );
  }
  const UNSAFE_COLOR_GROUPS = Array.from(process.env.UNSAFE_COLOR_GROUPS?.split(",") ?? []);
  if (UNSAFE_COLOR_GROUPS.length > 0) {
    console.warn(
      pc4.yellow(
        `
\u26A0\uFE0F UNSAFE_COLOR_GROUPS is set to ${pc4.blue(`[${UNSAFE_COLOR_GROUPS.join(", ")}]`)}. This will override the default color groups.`
      )
    );
  }
  const colorGroups = UNSAFE_COLOR_GROUPS.length > 0 ? UNSAFE_COLOR_GROUPS : [colorCategories.main, colorCategories.support].map((c) => `${c}-color`);
  buildOptions = options;
  buildOptions.defaultColor = UNSAFE_DEFAULT_COLOR;
  buildOptions.colorGroups = colorGroups;
  if (!buildOptions.defaultColor) {
    const customColors = getCustomColors(processed$themes, colorGroups);
    const firstMainColor = R23.head(customColors);
    buildOptions.defaultColor = firstMainColor;
  }
  if (buildOptions.defaultColor) {
    console.log(`
\u{1F3A8} Using ${pc4.blue(buildOptions.defaultColor)} as default color`);
  }
  const sizeModes = processed$themes.filter((x) => x.group === "size").map((x) => x.name);
  buildOptions.sizeModes = sizeModes;
  if (!buildOptions.defaultSize) {
    const defaultSize = R23.head(sizeModes);
    buildOptions.defaultSize = defaultSize;
  }
  if (buildOptions.defaultSize) {
    console.log(`
\u{1F4CF} Using ${pc4.blue(buildOptions.defaultSize)} as default size`);
  }
  const buildAndSdConfigs = R23.map((buildConfig) => {
    const sdConfigs = getConfigsForThemeDimensions(buildConfig.getConfig, processed$themes, buildConfig.dimensions, {
      tokensDir,
      tokenSets
    });
    const unknownConfigs = buildConfig.dimensions.map(
      (dimension) => sdConfigs.filter((x) => x.permutation[dimension] === "unknown")
    );
    for (const unknowns of unknownConfigs) {
      if (unknowns.length === sdConfigs.length) {
        buildConfig.enabled = () => false;
      }
    }
    return {
      buildConfig,
      sdConfigs
    };
  }, buildConfigs);
  const processedBuilds = {
    "color-scheme": [initResult],
    "main-color": [initResult],
    "support-color": [initResult],
    "neutral-color": [initResult],
    "success-color": [initResult],
    "danger-color": [initResult],
    "warning-color": [initResult],
    "info-color": [initResult],
    semantic: [initResult],
    typography: [initResult],
    sizeMode: [initResult],
    size: [initResult],
    typeScale: [initResult]
  };
  try {
    for (const [buildName, { buildConfig, sdConfigs }] of R23.toPairs(buildAndSdConfigs)) {
      if (!(buildConfig.enabled?.() ?? true)) {
        continue;
      }
      if (sdConfigs.length > 0) {
        console.log(`
\u{1F371} Building ${pc4.green(buildConfig.name ?? buildName)}`);
        const results = await Promise.all(
          sdConfigs.map(async (sdConfig) => {
            const { config, permutation } = sdConfig;
            const modes = ["theme", ...buildConfig.dimensions];
            const modeMessage = modes.map((x) => permutation[x]).join(" - ");
            const logMessage = R23.isNil(buildConfig.log) ? modeMessage : buildConfig?.log(sdConfig);
            console.log(logMessage);
            const sdOptions = { cache: true };
            const sdExtended = await sd.extend(config);
            const formatted = await sdExtended.formatPlatform(platform, sdOptions);
            const tokens = (await sdExtended.getPlatformTokens(platform, sdOptions)).allTokens;
            const result = {
              permutation,
              formatted,
              tokens
            };
            return Promise.resolve(result);
          })
        );
        processedBuilds[buildName] = results;
      }
    }
  } catch (err) {
    if (err instanceof Error) {
      err.message = err.message.replace('log.verbosity "verbose" or use ', "");
    }
    throw err;
  }
  return processedBuilds;
}

// src/tokens/format.ts
var formatTokens = async (options) => {
  const processedBuilds = await processPlatform({
    type: "format",
    buildTokenFormats: {},
    ...options
  });
  return processedBuilds;
};
var formatTheme = async (themeConfig) => {
  const { tokenSets } = await createTokens(themeConfig);
  const $themes = await generate$Themes(["dark", "light"], [themeConfig.name], themeConfig.colors);
  const processed$themes = $themes.map(processThemeObject);
  const processedBuilds = await formatTokens({
    tokenSets,
    processed$themes,
    verbose: false
  });
  return processedBuilds;
};
var formatThemeCSS = async (themeConfig) => {
  const processedBuilds = await formatTheme(themeConfig);
  const themeCSSFiles = createThemeCSSFiles({ processedBuilds });
  return R24.head(themeCSSFiles)?.output ?? "";
};
export {
  HSLToHex,
  RESERVED_COLORS,
  areColorsContrasting,
  baseColorNames,
  baseColors,
  canTextBeUsedOnColors,
  cliOptions,
  colorMetadata,
  colorNames,
  configFileCreateSchema as configSchema,
  convertColor,
  convertToHex,
  createTokens,
  dsLinkColor,
  formatThemeCSS,
  formatTokens,
  generateColorContrast,
  generateColorScale,
  generateColorSchemes,
  getColorMetadataByNumber,
  getContrastFromHex,
  getContrastFromLightness,
  getCssVariable,
  getLightnessFromHex,
  getLuminanceFromColor,
  getLuminanceFromLightness,
  hexToCssHsl,
  hexToHSL,
  hexToHsluv,
  hexToRgb,
  hslArrToCss,
  isHexColor,
  rgbToHex
};
