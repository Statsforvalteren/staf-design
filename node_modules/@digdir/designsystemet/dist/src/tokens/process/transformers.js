// src/tokens/process/transformers.ts
import { checkAndEvaluateMath } from "@tokens-studio/sd-transforms";
import * as R2 from "ramda";

// src/tokens/utils.ts
import * as R from "ramda";
var mapToLowerCase = R.map(R.toLower);
var hasAnyTruth = R.any(R.equals(true));
var getType = (token) => (token.$type ?? token.type) || "";
var getValue = (token) => token.$value ?? token.value;
var typeEquals = R.curry(
  (types, token) => {
    if (R.isNil(token)) {
      return false;
    }
    return R.includes(R.toLower(getType(token)), R.map(R.toLower, Array.isArray(types) ? types : [types]));
  }
);
var pathStartsWithOneOf = R.curry(
  (paths, token) => {
    if (R.isNil(token)) {
      return false;
    }
    const tokenPath = mapToLowerCase(token.path);
    const matchPathsStartingWith = R.map((pathOrString) => {
      const path = typeof pathOrString === "string" ? [pathOrString] : pathOrString;
      return R.startsWith(mapToLowerCase(path), tokenPath);
    }, paths);
    return hasAnyTruth(matchPathsStartingWith);
  }
);

// src/tokens/process/transformers.ts
var isPx = R2.test(/\b\d+px\b/g);
var sizeRem = {
  name: "ds/size/toRem",
  type: "value",
  transitive: true,
  filter: (token) => {
    const hasWantedType = typeEquals(["dimension", "fontsize"], token);
    const hasWantedPath = pathStartsWithOneOf([
      "border-radius",
      "font-size"
      /*, ['_size', 'mode-font-size']*/
    ], token);
    return hasWantedType && hasWantedPath;
  },
  transform: (token, config) => {
    const value = getValue(token);
    if (isPx(value)) {
      const baseFont = config.basePxFontSize || 16;
      const size = parseInt(value, 10);
      if (size === 0) {
        return "0";
      }
      return `${size / baseFont}rem`;
    }
    return value;
  }
};
var typographyName = {
  name: "name/typography",
  type: "name",
  transitive: true,
  // expanded tokens have different type so we match on path instead
  filter: (token) => pathStartsWithOneOf(["typography"], token),
  transform: (token) => {
    return token.name.replace("-typography", "");
  }
};
var resolveMath = {
  name: "ds/resolveMath",
  type: "value",
  transitive: true,
  filter: (token) => {
    const isValidValue = ["string", "object"].includes(typeof getValue(token));
    const isTokenOfInterest = !pathStartsWithOneOf(["border-radius"], token);
    return isValidValue && isTokenOfInterest;
  },
  transform: (token, platformCfg) => checkAndEvaluateMath(token, platformCfg.mathFractionDigits)
};
var unitless = {
  name: "ds/unitless",
  type: "value",
  transitive: true,
  filter: (token) => pathStartsWithOneOf(["size", "_size"], token),
  transform: (token) => parseInt(getValue(token), 10)
};
export {
  resolveMath,
  sizeRem,
  typographyName,
  unitless
};
