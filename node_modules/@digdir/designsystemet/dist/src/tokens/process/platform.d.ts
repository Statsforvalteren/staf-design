import type { TransformedToken } from 'style-dictionary/types';
import type { OutputFile, TokenSet } from '../types.js';
import { type ThemePermutation } from '../types.js';
import { type ProcessedThemeObject } from './utils/getMultidimensionalThemes.js';
type SharedOptions = {
    /** Enable verbose output */
    verbose: boolean;
    /** Set the default color for ":root" */
    defaultColor?: string;
    /** Set the default size mode */
    defaultSize?: string;
    /** Set the available size modes */
    sizeModes?: string[];
    /** Dry run, no files will be written */
    dry?: boolean;
    /** Token Studio `$themes.json` content */
    processed$themes: ProcessedThemeObject[];
    /** Color groups */
    colorGroups?: string[];
    /** Build token format map */
    buildTokenFormats: Record<string, {
        token: TransformedToken;
        formatted: string;
    }[]>;
};
export type BuildOptions = {
    type: 'build';
    /** Design tokens path */
    tokensDir: string;
    /** Output directory for built tokens */
    outDir: string;
    /** Tailwind CSS configuration */
    tailwind?: boolean;
} & SharedOptions;
export type FormatOptions = {
    type: 'format';
    /** Tokensets */
    tokenSets: Map<string, TokenSet>;
} & SharedOptions;
export type ProcessOptions = BuildOptions | FormatOptions;
type ProcessedBuildConfigs<T> = Record<keyof typeof buildConfigs, T>;
export type ProcessReturn = ProcessedBuildConfigs<BuildResult[]>;
type BuildResult = {
    permutation: ThemePermutation;
    formatted: OutputFile[];
    tokens: TransformedToken[];
};
export declare let buildOptions: SharedOptions;
declare const buildConfigs: {
    typography: {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "typography"[];
    };
    sizeMode: {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "size"[];
    };
    size: {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
    };
    typeScale: {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
    };
    'color-scheme': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "color-scheme"[];
    };
    'main-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "main-color"[];
    };
    'support-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "support-color"[];
    };
    'neutral-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
        log: ({ permutation: { theme } }: import("../types.js").SDConfigForThemePermutation) => string;
    };
    'success-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
        log: ({ permutation: { theme } }: import("../types.js").SDConfigForThemePermutation) => string;
    };
    'danger-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
        log: ({ permutation: { theme } }: import("../types.js").SDConfigForThemePermutation) => string;
    };
    'warning-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
        log: ({ permutation: { theme } }: import("../types.js").SDConfigForThemePermutation) => string;
    };
    'info-color': {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
        log: ({ permutation: { theme } }: import("../types.js").SDConfigForThemePermutation) => string;
    };
    semantic: {
        getConfig: import("./configs/shared.js").GetStyleDictionaryConfig;
        dimensions: "semantic"[];
    };
};
export declare function processPlatform(options: ProcessOptions): Promise<ProcessReturn>;
export {};
//# sourceMappingURL=platform.d.ts.map