// src/tokens/build.ts
import path from "path";
import pc6 from "picocolors";
import * as R17 from "ramda";

// src/utils.ts
import fs from "fs/promises";
import pc from "picocolors";
var mkdir = async (dir, dry) => {
  if (dry) {
    console.log(`${pc.blue("mkdir")} ${dir}`);
    return Promise.resolve();
  }
  const exists = await fs.access(dir, fs.constants.F_OK).then(() => true).catch(() => false);
  if (exists) {
    return Promise.resolve();
  }
  return fs.mkdir(dir, { recursive: true });
};
var writeFile = async (path2, data, dry) => {
  if (dry) {
    console.log(`${pc.blue("writeFile")} ${path2}`);
    return Promise.resolve();
  }
  return fs.writeFile(path2, data, { encoding: "utf-8" }).catch((error) => {
    console.error(pc.red(`Error writing file: ${path2}`));
    console.error(pc.red(error));
    throw error;
  });
};
var readFile = async (path2, dry, allowFileNotFound) => {
  if (dry) {
    console.log(`${pc.blue("readFile")} ${path2}`);
    return Promise.resolve("");
  }
  try {
    return await fs.readFile(path2, "utf-8");
  } catch (error) {
    if (allowFileNotFound && error.code === "ENOENT") {
      return "";
    }
    throw error;
  }
};

// src/tokens/process/output/declarations.ts
import pc4 from "picocolors";

// package.json
var package_default = {
  name: "@digdir/designsystemet",
  version: "1.7.1",
  description: "CLI for Designsystemet",
  author: "Designsystemet team",
  engines: {
    node: ">=20 <25"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/digdir/designsystemet.git"
  },
  homepage: "https://github.com/digdir/designsystemet/tree/main/packages/cli",
  license: "MIT",
  type: "module",
  main: "./dist/src/index.js",
  files: [
    "./dist/**",
    "./configs/**"
  ],
  bin: "dist/bin/designsystemet.js",
  exports: {
    ".": {
      import: "./dist/src/index.js"
    },
    "./color": {
      import: "./dist/src/colors/index.js"
    },
    "./tokens": {
      import: "./dist/src/tokens/index.js"
    },
    "./types": {
      import: "./dist/src/types.js"
    }
  },
  publishConfig: {
    access: "public"
  },
  scripts: {
    designsystemet: "tsx ./bin/designsystemet.ts",
    "designsystemet:inspect": "tsx --inspect-brk ./bin/designsystemet.ts",
    build: "tsup && pnpm build:types && pnpm build:json-schema",
    "build:types": "tsc --emitDeclarationOnly --declaration",
    "build:json-schema": "tsx ./src/scripts/createJsonSchema.ts",
    types: "tsc --noEmit",
    "test:tokens-create-options": 'pnpm run designsystemet tokens create -m dominant:"#007682" -n "#003333" -b 99 -o ./temp/options/design-tokens --theme options --clean',
    "test:tokens-create-config": "pnpm run designsystemet tokens create --config ./configs/test-tokens.config.json",
    "test:tokens-build": "pnpm run designsystemet tokens build -t ./temp/options/design-tokens -o ./temp/options/build --clean",
    "test:tokens-build-tailwind": "pnpm run designsystemet tokens build -t ./temp/options/design-tokens -o ./temp/options/build --clean --experimental-tailwind",
    "test:tokens-build-config": "pnpm run designsystemet tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean",
    "test:tokens-build-config:inspect": "pnpm run designsystemet:inspect tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean",
    "test:tokens-build-config-tailwind": "pnpm run designsystemet tokens build -t ./temp/config/design-tokens -o ./temp/config/build --clean --experimental-tailwind",
    "test:tokens-create-and-build-options": "pnpm test:tokens-create-options && pnpm test:tokens-build",
    "test:tokens-create-and-build-config": "pnpm test:tokens-create-config && pnpm test:tokens-build-config",
    test: "node -v && pnpm test:tokens-create-and-build-options && pnpm test:tokens-create-and-build-config",
    "digdir:tokens-build": "pnpm run designsystemet tokens build -t ../../internal/design-tokens -o ../../packages/theme/brand --clean --experimental-tailwind",
    "digdir:tokens-create": "pnpm run designsystemet tokens create --config ./configs/digdir.config.json",
    "update:template": "tsx ./src/scripts/update-template.ts",
    "update:preview-tokens": "tsx ./src/scripts/update-preview-tokens.ts",
    "update:theme-digdir": "pnpm digdir:tokens-create && tsx ./src/scripts/update-design-tokens.ts && pnpm digdir:tokens-build",
    verify: "pnpm test && pnpm update:template && pnpm update:theme-digdir && pnpm build:tokens"
  },
  dependencies: {
    "@commander-js/extra-typings": "^14.0.0",
    "@tokens-studio/sd-transforms": "1.3.0",
    "apca-w3": "^0.1.9",
    "change-case": "^5.4.4",
    "chroma-js": "^3.1.2",
    "colorjs.io": "^0.6.0-alpha.1",
    commander: "^14.0.1",
    "fast-glob": "^3.3.3",
    hsluv: "^1.0.1",
    "object-hash": "^3.0.0",
    picocolors: "^1.1.1",
    postcss: "^8.5.6",
    ramda: "^0.32.0",
    "style-dictionary": "^5.1.1",
    zod: "^4.1.12",
    "zod-validation-error": "^4.0.2"
  },
  devDependencies: {
    "@tokens-studio/types": "0.5.2",
    "@types/apca-w3": "^0.1.3",
    "@types/chroma-js": "^3.1.1",
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^22.18.11",
    "@types/object-hash": "^3.0.6",
    "@types/ramda": "^0.31.1",
    "fs-extra": "^11.3.2",
    tslib: "^2.8.1",
    tsup: "^8.5.0",
    tsx: "^4.20.6",
    typescript: "^5.9.3"
  }
};

// src/tokens/process/platform.ts
import pc3 from "picocolors";
import * as R15 from "ramda";
import StyleDictionary2 from "style-dictionary";

// src/tokens/types.ts
var colorCategories = {
  main: "main",
  support: "support"
};

// src/tokens/process/configs.ts
import { register } from "@tokens-studio/sd-transforms";
import * as R14 from "ramda";
import StyleDictionary from "style-dictionary";

// src/tokens/utils.ts
import * as R from "ramda";
var mapToLowerCase = R.map(R.toLower);
var hasAnyTruth = R.any(R.equals(true));
var getType = (token) => (token.$type ?? token.type) || "";
var getValue = (token) => token.$value ?? token.value;
var typeEquals = R.curry(
  (types, token) => {
    if (R.isNil(token)) {
      return false;
    }
    return R.includes(R.toLower(getType(token)), R.map(R.toLower, Array.isArray(types) ? types : [types]));
  }
);
var pathStartsWithOneOf = R.curry(
  (paths, token) => {
    if (R.isNil(token)) {
      return false;
    }
    const tokenPath = mapToLowerCase(token.path);
    const matchPathsStartingWith = R.map((pathOrString) => {
      const path2 = typeof pathOrString === "string" ? [pathOrString] : pathOrString;
      return R.startsWith(mapToLowerCase(path2), tokenPath);
    }, paths);
    return hasAnyTruth(matchPathsStartingWith);
  }
);
function isSemanticToken(token) {
  return token.filePath.includes("semantic/");
}
function isSemanticColorToken(token, color) {
  return token.filePath.includes("semantic/") && R.startsWith(["color", color], token.path);
}
function isGlobalColorToken(token) {
  return typeEquals("color", token) && pathStartsWithOneOf(["global"], token);
}
function isColorCategoryToken(token, category) {
  if (!category) {
    return Object.keys(colorCategories).some(
      (colorCategory2) => isColorCategoryToken(token, colorCategory2)
    );
  }
  return R.startsWith(["color", category], token.path);
}
var isDigit = (s) => /^\d+$/.test(s);
function traverseObj(obj, fn) {
  for (const key in obj) {
    const prop3 = obj[key];
    if (prop3 != null) {
      fn.apply(null, [obj, key, prop3]);
      if (typeof prop3 === "object") {
        traverseObj(prop3, fn);
      }
    }
  }
  return obj;
}
function inlineTokens(shouldInline, tokens) {
  const [inlineableTokens, otherTokens] = R.partition(shouldInline, tokens);
  return otherTokens.map((token) => {
    let transformed = getValue(token.original);
    for (const ref of inlineableTokens) {
      const refName = ref.path.join(".");
      if (typeof transformed === "string") {
        transformed = transformed.replaceAll(`{${refName}}`, getValue(ref.original));
      }
    }
    const tokenWithInlinedRefs = R.set(R.lensPath(["original", "$value"]), transformed, token);
    return tokenWithInlinedRefs;
  });
}
var sizeMap = {
  xsmall: "xs",
  small: "sm",
  medium: "md",
  large: "lg",
  xlarge: "xl"
};
function shortSizeName(size2) {
  return sizeMap[size2] ?? size2;
}
var sizeComparator = (size2) => {
  const sortIndex = Object.entries(sizeMap).findIndex(([key, val]) => key === size2 || val === size2);
  return sortIndex ?? 0;
};
function orderBySize(sizes) {
  return R.sortBy(sizeComparator, sizes);
}

// src/tokens/process/configs/color.ts
import * as R9 from "ramda";

// src/tokens/process/formats/css/color.ts
import * as R2 from "ramda";
import { createPropertyFormatter } from "style-dictionary/utils";
var prefersColorScheme = (colorScheme2, content) => `
@media (prefers-color-scheme: ${colorScheme2}) {
  [data-color-scheme="auto"] ${content}
}
`;
var colorScheme = {
  name: "ds/css-colorscheme",
  format: async ({ dictionary, options, platform }) => {
    const { allTokens } = dictionary;
    const { outputReferences, usesDtcg } = options;
    const { selector, colorScheme: colorScheme2, layer } = platform;
    const colorScheme_ = colorScheme2;
    const format = createPropertyFormatter({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const colorSchemeProperty = colorScheme_ === "dark" || colorScheme_ === "light" ? `
  color-scheme: ${colorScheme_};
` : "";
    const filteredAllTokens = allTokens.filter(
      R2.allPass([
        R2.anyPass([
          // Include semantic tokens in the output
          isSemanticToken,
          // Include global color tokens
          isGlobalColorToken
        ]),
        // Don't include color category tokens -- they are exported separately
        (t) => !isColorCategoryToken(t)
      ])
    );
    const formattedMap = filteredAllTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    const formattedTokens = formattedMap.map(R2.view(R2.lensProp("formatted"))).join("\n");
    const content = `{
${formattedTokens}
${colorSchemeProperty}}
`;
    const autoSelectorContent = ["light", "dark"].includes(colorScheme_) ? prefersColorScheme(colorScheme_, content) : "";
    const body = R2.isNotNil(layer) ? `@layer ${layer} {
${selector} ${content} ${autoSelectorContent}
}
` : `${selector} ${content} ${autoSelectorContent}
`;
    return body;
  }
};
var colorCategory = {
  name: "ds/css-colorcategory",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = R2.compose(
      createPropertyFormatter({
        outputReferences,
        dictionary,
        format: "css",
        usesDtcg
      }),
      (token) => ({
        ...token,
        name: token.name.replace(/color-\w+-/, "color-"),
        original: {
          ...token.original,
          $value: new RegExp(`color-(${colorCategories.main}|${colorCategories.support})-`).test(token.name) ? token.original.$value : `{${token.path.join(".")}}`
        }
      })
    );
    const formattedMap = dictionary.allTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R2.view(R2.lensProp("formatted"))).join("\n");
    const content = `{
${formattedTokens}
}
`;
    const body = R2.isNotNil(layer) ? `@layer ${layer} {
${selector} ${content}
}
` : `${selector} ${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/semantic.ts
import * as R4 from "ramda";
import { createPropertyFormatter as createPropertyFormatter3 } from "style-dictionary/utils";

// src/tokens/process/formats/css/size.ts
import * as R3 from "ramda";
import { createPropertyFormatter as createPropertyFormatter2 } from "style-dictionary/utils";
var isNumericBorderRadiusToken = (t) => t.path[0] === "border-radius" && isDigit(t.path[1]);
var isNumericSizeToken = (t) => pathStartsWithOneOf(["size"], t) && isDigit(t.path[1]);
var isSizeToken = (t) => pathStartsWithOneOf(["size"], t);
var isInlineTokens = R3.anyPass([isNumericBorderRadiusToken, isNumericSizeToken, isSizeToken]);
var overrideSizingFormula = (format, token) => {
  const [name, value] = format(token).replace(/;$/, "").split(": ");
  let calc;
  let round;
  if (token.path[1] === "unit") {
    calc = `calc(1rem * ${value})`;
  } else if (value.startsWith("floor")) {
    calc = value.replace(/^floor\((.*)\)$/, "calc($1)");
    round = `round(down, ${calc}, 1px)`;
  } else {
    calc = value.includes("*") ? `calc(${value})` : value;
  }
  return {
    name,
    round: round ?? calc,
    calc
  };
};
var formatSizingTokens = (format, tokens) => R3.reduce(
  (acc, token) => {
    const { round, calc, name } = overrideSizingFormula(format, token);
    return {
      tokens: [...acc.tokens, token],
      round: [...acc.round, `${name}: ${round};`],
      calc: [...acc.calc, `${name}: ${calc};`]
    };
  },
  { tokens: [], round: [], calc: [] },
  tokens
);
var sizingTemplate = ({ round, calc }) => {
  const usesRounding = round.filter((val, i) => val !== calc[i]);
  return `
${calc.join("\n")}

  @supports (width: round(down, .1em, 1px)) {
  ${usesRounding.join("\n  ")}
  }`;
};
var size = {
  name: "ds/css-size",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter2({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const tokens = inlineTokens(isInlineTokens, dictionary.allTokens);
    const filteredTokens = R3.reject((token) => R3.equals(["_size", "mode-font-size"], token.path), tokens);
    const [sizingTokens, restTokens] = R3.partition(
      (t) => pathStartsWithOneOf(["_size"], t) && (isDigit(t.path[1]) || t.path[1] === "unit"),
      filteredTokens
    );
    const formattedSizingTokens = formatSizingTokens(format, sizingTokens);
    const formattedMap = restTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    const formattedSizingMap = formattedSizingTokens.round.map((t, i) => ({
      token: formattedSizingTokens.tokens[i],
      formatted: t
    }));
    buildOptions.buildTokenFormats[destination] = [...formattedMap, ...formattedSizingMap];
    const formattedTokens = [formattedMap.map(R3.prop("formatted")).join("\n"), sizingTemplate(formattedSizingTokens)];
    const content = `${selector} {
${formattedTokens.join("\n")}
}
`;
    const body = R3.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/semantic.ts
var semantic = {
  name: "ds/css-semantic",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter3({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const tokens = inlineTokens(isInlineTokens, dictionary.allTokens);
    const formattedMap = tokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R4.prop("formatted")).join("\n");
    const content = `${selector} {
${formattedTokens}
}
`;
    const body = R4.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
    return body;
  }
};

// src/tokens/process/formats/css/size-mode.ts
import * as R6 from "ramda";
import { createPropertyFormatter as createPropertyFormatter4 } from "style-dictionary/utils";

// src/tokens/process/transformers.ts
import { checkAndEvaluateMath } from "@tokens-studio/sd-transforms";
import * as R5 from "ramda";
var isPx = R5.test(/\b\d+px\b/g);
var sizeRem = {
  name: "ds/size/toRem",
  type: "value",
  transitive: true,
  filter: (token) => {
    const hasWantedType = typeEquals(["dimension", "fontsize"], token);
    const hasWantedPath = pathStartsWithOneOf([
      "border-radius",
      "font-size"
      /*, ['_size', 'mode-font-size']*/
    ], token);
    return hasWantedType && hasWantedPath;
  },
  transform: (token, config) => {
    const value = getValue(token);
    if (isPx(value)) {
      const baseFont = config.basePxFontSize || 16;
      const size2 = parseInt(value, 10);
      if (size2 === 0) {
        return "0";
      }
      return `${size2 / baseFont}rem`;
    }
    return value;
  }
};
var typographyName = {
  name: "name/typography",
  type: "name",
  transitive: true,
  // expanded tokens have different type so we match on path instead
  filter: (token) => pathStartsWithOneOf(["typography"], token),
  transform: (token) => {
    return token.name.replace("-typography", "");
  }
};
var resolveMath = {
  name: "ds/resolveMath",
  type: "value",
  transitive: true,
  filter: (token) => {
    const isValidValue = ["string", "object"].includes(typeof getValue(token));
    const isTokenOfInterest = !pathStartsWithOneOf(["border-radius"], token);
    return isValidValue && isTokenOfInterest;
  },
  transform: (token, platformCfg) => checkAndEvaluateMath(token, platformCfg.mathFractionDigits)
};
var unitless = {
  name: "ds/unitless",
  type: "value",
  transitive: true,
  filter: (token) => pathStartsWithOneOf(["size", "_size"], token),
  transform: (token) => parseInt(getValue(token), 10)
};

// src/tokens/process/configs/shared.ts
var prefix = "ds";
var basePxFontSize = 16;
var dsTransformers = [
  "name/kebab",
  resolveMath.name,
  "ts/size/px",
  sizeRem.name,
  unitless.name,
  "ts/typography/fontWeight",
  typographyName.name,
  "ts/color/modifiers",
  "ts/color/css/hexrgba",
  "ts/size/lineheight",
  "shadow/css/shorthand"
];

// src/tokens/process/formats/css/size-mode.ts
var formatBaseSizeToken = (size2) => (token) => ({
  ...token,
  originalName: token.name,
  name: `${token.name}--${shortSizeName(size2)}`,
  $value: token.$value / basePxFontSize
});
var sizeMode = {
  name: "ds/css-size-mode",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer, size: size2 } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter4({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const sizeSpecificTokens = dictionary.allTokens.map(formatBaseSizeToken(size2));
    const sizeSpecificVariables = sizeSpecificTokens.map(format).join("\n");
    const formattedMap = sizeSpecificTokens.map((token) => ({
      token,
      formatted: format({
        ...token,
        // Remove the `--<size>` suffix for the token listing, since that is the only token we actually use
        name: token.originalName
      })
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const content = `${selector} /* ${size2} */ {
${sizeSpecificVariables}
}`;
    const body = wrapInLayer(content, layer);
    const sizes = orderBySize(buildOptions?.sizeModes ?? []).map(shortSizeName);
    const defaultSize = shortSizeName(buildOptions?.defaultSize ?? "");
    const sizingToggles = `:root, [data-size] {
  --ds-size: var(--ds-size--${defaultSize});
${sizes.map((size3) => `  --ds-size--${size3}: var(--ds-size,);`).join("\n")}
  --ds-size-mode-font-size:
${sizes.map((size3) => `    var(--ds-size--${size3}, var(--ds-size-mode-font-size--${size3}))`).join("\n")};
}`;
    const sizingHelpers = sizes.map((size3) => `[data-size='${size3}'] { --ds-size: var(--ds-size--${size3}); }`).join("\n");
    const sharedContent = `${sizingToggles}

${sizingHelpers}`;
    const sharedBody = shortSizeName(size2) === R6.last(sizes) ? `
${wrapInLayer(sharedContent, layer)}` : "";
    return body + sharedBody;
  }
};
function wrapInLayer(content, layer) {
  return R6.isNotNil(layer) ? `@layer ${layer} {
${content}
}
` : `${content}
`;
}

// src/tokens/process/formats/css/typography.ts
import * as R7 from "ramda";
import { createPropertyFormatter as createPropertyFormatter5 } from "style-dictionary/utils";
var typographyFontFamilyPredicate = R7.allPass([
  R7.pathSatisfies(R7.includes("typography"), ["path"]),
  R7.pathSatisfies(R7.includes("fontFamily"), ["path"])
]);
var typography = {
  name: "ds/css-typography",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter5({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const filteredTokens = R7.reject(typographyFontFamilyPredicate, dictionary.allTokens);
    const formattedMap = filteredTokens.map((token) => ({
      token,
      formatted: format(token)
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const formattedTokens = formattedMap.map(R7.view(R7.lensProp("formatted"))).join("\n");
    const content = selector ? `${selector} {
${formattedTokens}
}` : formattedTokens;
    const body = R7.isNotNil(layer) ? `@layer ${layer} {
${content}
}` : content;
    return body;
  }
};

// src/tokens/process/formats/css/type-scale.ts
import * as R8 from "ramda";
import { createPropertyFormatter as createPropertyFormatter6 } from "style-dictionary/utils";
var isTypographyFontFamilyToken = R8.allPass([
  R8.pathSatisfies(R8.includes("typography"), ["path"]),
  R8.pathSatisfies(R8.includes("fontFamily"), ["path"])
]);
var formatTypographySizeToken = (format, token) => {
  const [name, value] = format(token).replace(/;$/, "").split(": ");
  let calc;
  let round;
  if (R8.startsWith(["font-size"], token.path)) {
    calc = `calc(${value} * var(--_ds-font-size-factor))`;
    round = `round(${calc}, 1px)`;
  } else {
    calc = value;
  }
  return { name, calc, round: round ?? calc };
};
var formatTypographySizeTokens = (format, tokens) => R8.reduce(
  (acc, token) => {
    const { name, calc, round } = formatTypographySizeToken(format, token);
    acc.tokens.push(token);
    acc.calc.push(`${name}: ${calc};`);
    acc.round.push(`${name}: ${round};`);
    return acc;
  },
  { tokens: [], calc: [], round: [] },
  tokens
);
var typeScale = {
  name: "ds/css-type-scale",
  format: async ({ dictionary, file, options, platform }) => {
    const { outputReferences, usesDtcg } = options;
    const { selector, layer } = platform;
    const destination = file.destination;
    const format = createPropertyFormatter6({
      outputReferences,
      dictionary,
      format: "css",
      usesDtcg
    });
    const filteredTokens = R8.reject(R8.anyPass([isTypographyFontFamilyToken]), dictionary.allTokens);
    const formattedTokens = formatTypographySizeTokens(format, filteredTokens);
    const formattedMap = formattedTokens.round.map((t, i) => ({
      token: formattedTokens.tokens[i],
      formatted: t
    }));
    buildOptions.buildTokenFormats[destination] = formattedMap;
    const sizeFactor = `  --_ds-font-size-factor: calc(var(--ds-size-mode-font-size) / (var(--ds-size-base) / ${basePxFontSize}));`;
    const content = `${selector} {
${sizeFactor}${sizingTemplate(formattedTokens)}
}`;
    const body = R8.isNotNil(layer) ? `@layer ${layer} {
${content}
}` : content;
    return body;
  }
};

// src/tokens/process/formats/css.ts
var formats = {
  colorScheme,
  colorCategory,
  semantic,
  sizeMode,
  size,
  typography,
  typeScale
};

// src/tokens/process/configs/color.ts
var colorSchemeVariables = ({ "color-scheme": colorScheme2 = "light", theme }) => {
  const selector = `${colorScheme2 === "light" ? ":root, " : ""}[data-color-scheme="${colorScheme2}"]`;
  const layer = `ds.theme.color-scheme.${colorScheme2}`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        colorScheme: colorScheme2,
        theme,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `color-scheme/${colorScheme2}.css`,
            format: formats.colorScheme.name,
            filter: (token) => typeEquals("color", token) && !R9.startsWith(["global"], token.path)
          }
        ],
        options: {
          outputReferences: false
        }
      }
    }
  };
};
var colorCategoryVariables = (opts) => ({ "color-scheme": colorScheme2, theme, ...permutation }) => {
  const category = opts.category;
  const color = category === "builtin" ? opts.color : permutation[`${category}-color`];
  if (!color) {
    throw new Error(
      category === "builtin" ? `Missing color for built-in color ${opts.color}` : `Missing color for category ${category}`
    );
  }
  const layer = `ds.theme.color`;
  const isRootColor = color === buildOptions?.defaultColor;
  const selector = isRootColor ? `:root, [data-color-scheme], [data-color="${color}"]` : `[data-color="${color}"], [data-color-scheme][data-color="${color}"]`;
  const config = {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        colorScheme: colorScheme2,
        theme,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `color/${color}.css`,
            format: formats.colorCategory.name,
            filter: (token) => category === "builtin" ? isSemanticColorToken(token, color) : isColorCategoryToken(token, category)
          }
        ],
        options: {
          outputReferences: true
        }
      }
    }
  };
  return config;
};

// src/tokens/process/configs/semantic.ts
import * as R10 from "ramda";
import { outputReferencesFilter } from "style-dictionary/utils";
var semanticVariables = ({ theme }) => {
  const selector = `:root`;
  const layer = `ds.theme.semantic`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `semantic.css`,
            format: formats.semantic.name,
            filter: (token) => {
              const isUwantedToken = R10.anyPass([R10.includes("primitives/global")])(token.filePath);
              const isPrivateToken = R10.includes("_", token.path);
              const unwantedPaths = pathStartsWithOneOf(
                ["size", "_size", "font-size", "line-height", "letter-spacing"],
                token
              );
              const unwantedTypes = typeEquals(["color", "fontWeight", "fontFamily", "typography"], token);
              const unwantedTokens = !(unwantedPaths || unwantedTypes || isPrivateToken || isUwantedToken);
              return unwantedTokens;
            }
          }
        ],
        options: {
          outputReferences: (token, options) => {
            const include = pathStartsWithOneOf(["border-radius"], token);
            return include && outputReferencesFilter(token, options);
          }
        }
      }
    }
  };
};

// src/tokens/process/configs/size.ts
import * as R11 from "ramda";
import { outputReferencesFilter as outputReferencesFilter2 } from "style-dictionary/utils";
var sizeVariables = ({ theme }) => {
  const selector = `:root, [data-size]`;
  const layer = `ds.theme.size`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `size.css`,
            format: formats.size.name,
            filter: (token) => {
              const isUwantedToken = R11.anyPass([R11.includes("primitives/global")])(token.filePath);
              const isPrivateToken = R11.includes("_", token.path);
              return pathStartsWithOneOf(["size", "_size"], token) && !(isUwantedToken || isPrivateToken);
            }
          }
        ],
        options: {
          outputReferences: (token, options) => {
            const isWantedSize = pathStartsWithOneOf(["size", "_size"], token) && (isDigit(token.path[1]) || token.path[1] === "unit");
            return isWantedSize && outputReferencesFilter2(token, options);
          }
        }
      }
    }
  };
};

// src/tokens/process/configs/size-mode.ts
import * as R12 from "ramda";
var sizeModeVariables = ({ theme, size: size2 }) => {
  const selector = `:root`;
  const layer = `ds.theme.size-mode`;
  return {
    preprocessors: ["tokens-studio"],
    platforms: {
      css: {
        // custom
        size: size2,
        theme,
        basePxFontSize,
        selector,
        layer,
        //
        prefix,
        buildPath: `${theme}/`,
        transforms: dsTransformers,
        files: [
          {
            destination: `size-mode/${size2}.css`,
            format: formats.sizeMode.name,
            filter: (token) => {
              return R12.equals(["_size", "mode-font-size"], token.path);
            }
          }
        ]
      }
    }
  };
};

// src/tokens/process/configs/type-scale.ts
var typeScaleVariables = ({ theme }) => {
  const selector = ":root, [data-size]";
  const layer = `ds.theme.type-scale`;
  return {
    usesDtcg: true,
    preprocessors: ["tokens-studio"],
    expand: {
      include: ["typography"]
    },
    platforms: {
      css: {
        prefix,
        selector,
        layer,
        buildPath: `${theme}/`,
        basePxFontSize,
        transforms: [
          "name/kebab",
          "ts/size/px",
          sizeRem.name,
          "ts/size/lineheight",
          "ts/typography/fontWeight",
          typographyName.name
        ],
        files: [
          {
            destination: `type-scale.css`,
            format: formats.typeScale.name,
            filter: (token) => {
              const included = typeEquals(["typography", "dimension", "fontsize"], token);
              if (/primitives\/modes\/typography\/(primary|secondary)/.test(token.filePath)) return false;
              return included && !pathStartsWithOneOf(["spacing", "sizing", "size", "border-width", "border-radius"], token) && (pathStartsWithOneOf(["font-size"], token) || token.path.includes("fontSize"));
            }
          }
        ],
        options: {
          outputReferences: (token) => pathStartsWithOneOf(["typography"], token) && token.path.includes("fontSize")
        }
      }
    }
  };
};

// src/tokens/process/configs/typography.ts
import { expandTypesMap } from "@tokens-studio/sd-transforms";
var typographyVariables = ({ theme, typography: typography2 }) => {
  const selector = `${typography2 === "primary" ? ":root, " : ""}[data-typography="${typography2}"]`;
  const layer = `ds.theme.typography.${typography2}`;
  return {
    usesDtcg: true,
    preprocessors: ["tokens-studio"],
    expand: {
      include: ["typography"],
      typesMap: { ...expandTypesMap, typography: { ...expandTypesMap.typography, letterSpacing: "dimension" } }
    },
    platforms: {
      css: {
        prefix,
        typography: typography2,
        selector,
        layer,
        buildPath: `${theme}/`,
        basePxFontSize,
        transforms: [
          "name/kebab",
          "ts/size/px",
          sizeRem.name,
          "ts/size/lineheight",
          "ts/typography/fontWeight",
          "ts/size/css/letterspacing",
          typographyName.name
        ],
        files: [
          {
            destination: `typography/${typography2}.css`,
            format: formats.typography.name,
            filter: (token) => {
              const included = typeEquals(["fontweight", "fontFamily", "lineHeight", "dimension"], token);
              if (/primitives\/modes\/typography\/(primary|secondary)/.test(token.filePath)) return false;
              return included && !pathStartsWithOneOf(["spacing", "sizing", "size", "_size", "border-width", "border-radius"], token) && !(pathStartsWithOneOf(["typography"], token) && token.path.includes("fontSize"));
            }
          }
        ]
      }
    }
  };
};

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BoxShadowTypes.js
var BoxShadowTypes;
(function(BoxShadowTypes2) {
  BoxShadowTypes2["DROP_SHADOW"] = "dropShadow";
  BoxShadowTypes2["INNER_SHADOW"] = "innerShadow";
})(BoxShadowTypes || (BoxShadowTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/ColorModifierTypes.js
var ColorModifierTypes;
(function(ColorModifierTypes2) {
  ColorModifierTypes2["LIGHTEN"] = "lighten";
  ColorModifierTypes2["DARKEN"] = "darken";
  ColorModifierTypes2["MIX"] = "mix";
  ColorModifierTypes2["ALPHA"] = "alpha";
})(ColorModifierTypes || (ColorModifierTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/ColorSpaceTypes.js
var ColorSpaceTypes;
(function(ColorSpaceTypes2) {
  ColorSpaceTypes2["LCH"] = "lch";
  ColorSpaceTypes2["SRGB"] = "srgb";
  ColorSpaceTypes2["P3"] = "p3";
  ColorSpaceTypes2["HSL"] = "hsl";
})(ColorSpaceTypes || (ColorSpaceTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/Properties.js
var Properties;
(function(Properties2) {
  Properties2["sizing"] = "sizing";
  Properties2["height"] = "height";
  Properties2["width"] = "width";
  Properties2["spacing"] = "spacing";
  Properties2["verticalPadding"] = "verticalPadding";
  Properties2["horizontalPadding"] = "horizontalPadding";
  Properties2["paddingTop"] = "paddingTop";
  Properties2["paddingRight"] = "paddingRight";
  Properties2["paddingBottom"] = "paddingBottom";
  Properties2["paddingLeft"] = "paddingLeft";
  Properties2["itemSpacing"] = "itemSpacing";
  Properties2["fill"] = "fill";
  Properties2["backgroundBlur"] = "backgroundBlur";
  Properties2["border"] = "border";
  Properties2["borderTop"] = "borderTop";
  Properties2["borderRight"] = "borderRight";
  Properties2["borderBottom"] = "borderBottom";
  Properties2["borderLeft"] = "borderLeft";
  Properties2["borderColor"] = "borderColor";
  Properties2["borderRadius"] = "borderRadius";
  Properties2["borderRadiusTopLeft"] = "borderRadiusTopLeft";
  Properties2["borderRadiusTopRight"] = "borderRadiusTopRight";
  Properties2["borderRadiusBottomRight"] = "borderRadiusBottomRight";
  Properties2["borderRadiusBottomLeft"] = "borderRadiusBottomLeft";
  Properties2["borderWidth"] = "borderWidth";
  Properties2["borderWidthTop"] = "borderWidthTop";
  Properties2["borderWidthRight"] = "borderWidthRight";
  Properties2["borderWidthBottom"] = "borderWidthBottom";
  Properties2["borderWidthLeft"] = "borderWidthLeft";
  Properties2["boxShadow"] = "boxShadow";
  Properties2["opacity"] = "opacity";
  Properties2["fontFamilies"] = "fontFamilies";
  Properties2["fontWeights"] = "fontWeights";
  Properties2["fontSizes"] = "fontSizes";
  Properties2["lineHeights"] = "lineHeights";
  Properties2["typography"] = "typography";
  Properties2["composition"] = "composition";
  Properties2["letterSpacing"] = "letterSpacing";
  Properties2["paragraphSpacing"] = "paragraphSpacing";
  Properties2["textCase"] = "textCase";
  Properties2["dimension"] = "dimension";
  Properties2["textDecoration"] = "textDecoration";
  Properties2["asset"] = "asset";
  Properties2["tokenValue"] = "tokenValue";
  Properties2["value"] = "value";
  Properties2["tokenName"] = "tokenName";
  Properties2["description"] = "description";
})(Properties || (Properties = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TokenSetStatus.js
var TokenSetStatus;
(function(TokenSetStatus2) {
  TokenSetStatus2["DISABLED"] = "disabled";
  TokenSetStatus2["SOURCE"] = "source";
  TokenSetStatus2["ENABLED"] = "enabled";
})(TokenSetStatus || (TokenSetStatus = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TokenTypes.js
var TokenTypes;
(function(TokenTypes2) {
  TokenTypes2["OTHER"] = "other";
  TokenTypes2["COLOR"] = "color";
  TokenTypes2["BORDER_RADIUS"] = "borderRadius";
  TokenTypes2["SIZING"] = "sizing";
  TokenTypes2["SPACING"] = "spacing";
  TokenTypes2["TEXT"] = "text";
  TokenTypes2["TYPOGRAPHY"] = "typography";
  TokenTypes2["OPACITY"] = "opacity";
  TokenTypes2["BORDER_WIDTH"] = "borderWidth";
  TokenTypes2["STROKE_STYLE"] = "strokeStyle";
  TokenTypes2["BOX_SHADOW"] = "boxShadow";
  TokenTypes2["FONT_FAMILIES"] = "fontFamilies";
  TokenTypes2["FONT_WEIGHTS"] = "fontWeights";
  TokenTypes2["LINE_HEIGHTS"] = "lineHeights";
  TokenTypes2["FONT_SIZES"] = "fontSizes";
  TokenTypes2["LETTER_SPACING"] = "letterSpacing";
  TokenTypes2["PARAGRAPH_SPACING"] = "paragraphSpacing";
  TokenTypes2["PARAGRAPH_INDENT"] = "paragraphIndent";
  TokenTypes2["TEXT_DECORATION"] = "textDecoration";
  TokenTypes2["TEXT_CASE"] = "textCase";
  TokenTypes2["COMPOSITION"] = "composition";
  TokenTypes2["DIMENSION"] = "dimension";
  TokenTypes2["BORDER"] = "border";
  TokenTypes2["ASSET"] = "asset";
  TokenTypes2["BOOLEAN"] = "boolean";
  TokenTypes2["NUMBER"] = "number";
})(TokenTypes || (TokenTypes = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BorderValues.js
var BorderValues;
(function(BorderValues2) {
  BorderValues2["BORDER_COLOR"] = "color";
  BorderValues2["BORDER_WIDTH"] = "width";
  BorderValues2["BORDER_STYLE"] = "style";
})(BorderValues || (BorderValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/StrokeStyleValues.js
var StrokeStyleValues;
(function(StrokeStyleValues2) {
  StrokeStyleValues2["SOLID"] = "solid";
  StrokeStyleValues2["DASHED"] = "dashed";
  StrokeStyleValues2["DOTTED"] = "dotted";
  StrokeStyleValues2["DOUBLE"] = "double";
  StrokeStyleValues2["GROOVE"] = "groove";
  StrokeStyleValues2["RIDGE"] = "ridge";
  StrokeStyleValues2["OUTSET"] = "outset";
  StrokeStyleValues2["INSET"] = "inset";
})(StrokeStyleValues || (StrokeStyleValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/BoxShadowValues.js
var BoxShadowValues;
(function(BoxShadowValues2) {
  BoxShadowValues2["TYPE"] = "type";
  BoxShadowValues2["COLOR"] = "color";
  BoxShadowValues2["X"] = "x";
  BoxShadowValues2["Y"] = "y";
  BoxShadowValues2["BLUR"] = "blur";
  BoxShadowValues2["SPREAD"] = "spread";
  BoxShadowValues2["BLEND_MODE"] = "blendMode";
})(BoxShadowValues || (BoxShadowValues = {}));

// ../../node_modules/.pnpm/@tokens-studio+types@0.5.2/node_modules/@tokens-studio/types/dist/constants/TypographyValues.js
var TypographyValues;
(function(TypographyValues2) {
  TypographyValues2["FONT_FAMILY"] = "fontFamily";
  TypographyValues2["FONT_WEIGHT"] = "fontWeight";
  TypographyValues2["LINE_HEIGHT"] = "lineHeight";
  TypographyValues2["FONT_SIZE"] = "fontSize";
  TypographyValues2["LETTER_SPACING"] = "letterSpacing";
  TypographyValues2["PARAGRAPH_SPACING"] = "paragraphSpacing";
  TypographyValues2["PARAGRAPH_INDENT"] = "paragraphIndent";
  TypographyValues2["TEXT_DECORATION"] = "textDecoration";
  TypographyValues2["TEXT_CASE"] = "textCase";
})(TypographyValues || (TypographyValues = {}));

// src/tokens/process/utils/getMultidimensionalThemes.ts
import { kebabCase } from "change-case";
import pc2 from "picocolors";
import * as R13 from "ramda";
var getMultidimensionalThemes = (processed$themes, dimensions) => {
  const verboseLogging = buildOptions?.verbose;
  const grouped$themes = groupThemes(processed$themes);
  const permutations = permutateThemes(grouped$themes);
  const ALL_DEPENDENT_ON = ["theme"];
  const keys2 = R13.keys(grouped$themes);
  const nonDependentKeys = keys2.filter((x) => ![...ALL_DEPENDENT_ON, ...dimensions].includes(x));
  if (verboseLogging) {
    console.log(pc2.cyan(`\u{1F50E} Finding theme permutations for ${dimensions}`));
    console.log(pc2.cyan(`   (ignoring permutations for ${nonDependentKeys})`));
  }
  return permutations.filter((val) => {
    const filters = nonDependentKeys.map((x) => val.permutation[x] === grouped$themes[x][0].name);
    return filters.every((x) => x);
  });
};
var processed = Symbol("Type brand for ProcessedThemeObject");
function isProcessed(theme) {
  return Boolean(theme[processed]);
}
function processThemeObject(theme) {
  if (isProcessed(theme)) {
    return theme;
  }
  const result = { ...theme, [processed]: true };
  if (result.group) {
    result.group = kebabCase(result.group);
  }
  result.name = kebabCase(result.name);
  return result;
}
function groupThemes(themes) {
  const groups = {};
  for (const theme of themes) {
    if (theme.group) {
      const groupKey = theme.group;
      groups[groupKey] = [...groups[groupKey] ?? [], theme];
    } else {
      throw new Error(
        `Theme ${theme.name} does not have a group property, which is required for multi-dimensional theming.`
      );
    }
  }
  return groups;
}
var hasUnknownProps = R13.pipe(R13.values, R13.none(R13.equals("unknown")), R13.not);
function permutateThemes(groups) {
  const separator = "_";
  const permutations = cartesian(Object.values(groups));
  const permutatedThemes = permutations.map((perm) => {
    const permutatedTheme = perm.reduce(
      (acc, theme) => {
        const { group, name, selectedTokenSets } = theme;
        let updatedPermutation = acc.permutation;
        if (group) {
          const groupProp = R13.lensProp(group);
          updatedPermutation = R13.set(groupProp, name, updatedPermutation);
        }
        const updatedName = `${String(acc.name)}${acc ? separator : ""}${name}`;
        const sets = [...acc.selectedTokenSets, ...filterTokenSets(selectedTokenSets)];
        return {
          permutation: updatedPermutation,
          name: updatedName,
          selectedTokenSets: sets
        };
      },
      {
        name: "",
        selectedTokenSets: [],
        permutation: {
          "color-scheme": "unknown",
          "main-color": "unknown",
          "support-color": "unknown",
          theme: "unknown",
          semantic: "unknown",
          size: "unknown",
          typography: "unknown"
        }
      }
    );
    if (hasUnknownProps(permutatedTheme)) {
      throw Error(`Theme ${permutatedTheme.name} has unknown props: ${JSON.stringify(permutatedTheme)}`);
    }
    const uniqueTokenSets = new Set(permutatedTheme.selectedTokenSets);
    return { ...permutatedTheme, selectedTokenSets: Array.from(uniqueTokenSets) };
  });
  return permutatedThemes;
}
function filterTokenSets(tokensets) {
  return Object.entries(tokensets).filter(([, val]) => val !== TokenSetStatus.DISABLED).sort((a, b) => {
    if (a[1] === TokenSetStatus.SOURCE && b[1] === TokenSetStatus.ENABLED) {
      return -1;
    }
    if (a[1] === TokenSetStatus.ENABLED && b[1] === TokenSetStatus.SOURCE) {
      return 1;
    }
    return 0;
  }).map((entry) => entry[0]);
}
function cartesian(a) {
  return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
}
var getCustomColors = (processed$themes, colorGroups) => processed$themes.filter((x) => {
  if (!x.group) {
    return false;
  }
  return colorGroups.includes(x.group);
}).map((x) => x.name);

// src/tokens/process/configs.ts
void register(StyleDictionary, { withSDBuiltins: false });
StyleDictionary.registerTransform(sizeRem);
StyleDictionary.registerTransform(typographyName);
StyleDictionary.registerTransform(resolveMath);
StyleDictionary.registerTransform(unitless);
for (const format of Object.values(formats)) {
  StyleDictionary.registerFormat(format);
}
var configs = {
  colorSchemeVariables,
  mainColorVariables: colorCategoryVariables({ category: "main" }),
  supportColorVariables: colorCategoryVariables({ category: "support" }),
  neutralColorVariables: colorCategoryVariables({ category: "builtin", color: "neutral" }),
  successColorVariables: colorCategoryVariables({ category: "builtin", color: "success" }),
  dangerColorVariables: colorCategoryVariables({ category: "builtin", color: "danger" }),
  warningColorVariables: colorCategoryVariables({ category: "builtin", color: "warning" }),
  infoColorVariables: colorCategoryVariables({ category: "builtin", color: "info" }),
  sizeModeVariables,
  sizeVariables,
  typographyVariables,
  typeScaleVariables,
  semanticVariables
};
var getConfigsForThemeDimensions = (getConfig, processed$themes, dimensions, options) => {
  const { tokensDir, tokenSets } = options;
  const permutations = getMultidimensionalThemes(processed$themes, dimensions);
  return permutations.flatMap(({ selectedTokenSets, permutation }) => {
    const tokenSource = { source: void 0, tokens: {} };
    if (tokenSets) {
      for (const tokenSet of selectedTokenSets) {
        const tokens = tokenSets.get(tokenSet);
        if (tokens) {
          const tokensWithFilePath = traverseObj(tokens, (obj) => {
            if (Object.hasOwn(obj, `$value`) && !obj.filePath) {
              obj.filePath = tokenSet;
            }
          });
          tokenSource.tokens = R14.mergeDeepRight(tokenSource.tokens, tokensWithFilePath);
        }
      }
    } else {
      tokenSource.source = selectedTokenSets.map((x) => `${tokensDir}/${x}.json`);
    }
    const configOrConfigs = getConfig(permutation);
    const configs_ = Array.isArray(configOrConfigs) ? configOrConfigs : [{ config: configOrConfigs }];
    const configs2 = configs_.map(({ config, permutationOverrides }) => {
      return {
        permutation: { ...permutation, ...permutationOverrides },
        config: {
          ...config,
          /** Use official W3C design token format
          @see https://v4.styledictionary.com/info/dtcg/
          @see https://design-tokens.github.io/community-group/format/ */
          usesDtcg: true,
          log: {
            ...config?.log,
            verbosity: buildOptions?.verbose ? "verbose" : "silent"
          },
          ...tokenSource
        }
      };
    });
    return configs2;
  }).sort();
};

// src/tokens/process/platform.ts
var initResult = {
  formatted: [],
  tokens: [],
  permutation: {
    "color-scheme": "",
    "main-color": "",
    "support-color": "",
    semantic: "",
    size: "",
    theme: "",
    typography: ""
  }
};
var buildOptions = {
  verbose: false,
  processed$themes: [],
  buildTokenFormats: {}
};
var sd = new StyleDictionary2();
var buildConfigs = {
  typography: { getConfig: configs.typographyVariables, dimensions: ["typography"] },
  sizeMode: { getConfig: configs.sizeModeVariables, dimensions: ["size"] },
  size: { getConfig: configs.sizeVariables, dimensions: ["semantic"] },
  typeScale: { getConfig: configs.typeScaleVariables, dimensions: ["semantic"] },
  "color-scheme": { getConfig: configs.colorSchemeVariables, dimensions: ["color-scheme"] },
  "main-color": { getConfig: configs.mainColorVariables, dimensions: ["main-color"] },
  "support-color": { getConfig: configs.supportColorVariables, dimensions: ["support-color"] },
  "neutral-color": {
    getConfig: configs.neutralColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - neutral`
  },
  "success-color": {
    getConfig: configs.successColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - success`
  },
  "danger-color": {
    getConfig: configs.dangerColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - danger`
  },
  "warning-color": {
    getConfig: configs.warningColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - warning`
  },
  "info-color": {
    getConfig: configs.infoColorVariables,
    dimensions: ["semantic"],
    log: ({ permutation: { theme } }) => `${theme} - info`
  },
  semantic: { getConfig: configs.semanticVariables, dimensions: ["semantic"] }
};
async function processPlatform(options) {
  const { type, processed$themes } = options;
  const platform = "css";
  const tokenSets = type === "format" ? options.tokenSets : void 0;
  const tokensDir = type === "build" ? options.tokensDir : void 0;
  const UNSAFE_DEFAULT_COLOR = process.env.UNSAFE_DEFAULT_COLOR ?? "";
  if (UNSAFE_DEFAULT_COLOR) {
    console.warn(
      pc3.yellow(
        `
\u26A0\uFE0F UNSAFE_DEFAULT_COLOR is set to ${pc3.blue(UNSAFE_DEFAULT_COLOR)}. This will override the default color.`
      )
    );
  }
  const UNSAFE_COLOR_GROUPS = Array.from(process.env.UNSAFE_COLOR_GROUPS?.split(",") ?? []);
  if (UNSAFE_COLOR_GROUPS.length > 0) {
    console.warn(
      pc3.yellow(
        `
\u26A0\uFE0F UNSAFE_COLOR_GROUPS is set to ${pc3.blue(`[${UNSAFE_COLOR_GROUPS.join(", ")}]`)}. This will override the default color groups.`
      )
    );
  }
  const colorGroups = UNSAFE_COLOR_GROUPS.length > 0 ? UNSAFE_COLOR_GROUPS : [colorCategories.main, colorCategories.support].map((c) => `${c}-color`);
  buildOptions = options;
  buildOptions.defaultColor = UNSAFE_DEFAULT_COLOR;
  buildOptions.colorGroups = colorGroups;
  if (!buildOptions.defaultColor) {
    const customColors = getCustomColors(processed$themes, colorGroups);
    const firstMainColor = R15.head(customColors);
    buildOptions.defaultColor = firstMainColor;
  }
  if (buildOptions.defaultColor) {
    console.log(`
\u{1F3A8} Using ${pc3.blue(buildOptions.defaultColor)} as default color`);
  }
  const sizeModes = processed$themes.filter((x) => x.group === "size").map((x) => x.name);
  buildOptions.sizeModes = sizeModes;
  if (!buildOptions.defaultSize) {
    const defaultSize = R15.head(sizeModes);
    buildOptions.defaultSize = defaultSize;
  }
  if (buildOptions.defaultSize) {
    console.log(`
\u{1F4CF} Using ${pc3.blue(buildOptions.defaultSize)} as default size`);
  }
  const buildAndSdConfigs = R15.map((buildConfig) => {
    const sdConfigs = getConfigsForThemeDimensions(buildConfig.getConfig, processed$themes, buildConfig.dimensions, {
      tokensDir,
      tokenSets
    });
    const unknownConfigs = buildConfig.dimensions.map(
      (dimension) => sdConfigs.filter((x) => x.permutation[dimension] === "unknown")
    );
    for (const unknowns of unknownConfigs) {
      if (unknowns.length === sdConfigs.length) {
        buildConfig.enabled = () => false;
      }
    }
    return {
      buildConfig,
      sdConfigs
    };
  }, buildConfigs);
  const processedBuilds = {
    "color-scheme": [initResult],
    "main-color": [initResult],
    "support-color": [initResult],
    "neutral-color": [initResult],
    "success-color": [initResult],
    "danger-color": [initResult],
    "warning-color": [initResult],
    "info-color": [initResult],
    semantic: [initResult],
    typography: [initResult],
    sizeMode: [initResult],
    size: [initResult],
    typeScale: [initResult]
  };
  try {
    for (const [buildName, { buildConfig, sdConfigs }] of R15.toPairs(buildAndSdConfigs)) {
      if (!(buildConfig.enabled?.() ?? true)) {
        continue;
      }
      if (sdConfigs.length > 0) {
        console.log(`
\u{1F371} Building ${pc3.green(buildConfig.name ?? buildName)}`);
        const results = await Promise.all(
          sdConfigs.map(async (sdConfig) => {
            const { config, permutation } = sdConfig;
            const modes = ["theme", ...buildConfig.dimensions];
            const modeMessage = modes.map((x) => permutation[x]).join(" - ");
            const logMessage = R15.isNil(buildConfig.log) ? modeMessage : buildConfig?.log(sdConfig);
            console.log(logMessage);
            const sdOptions = { cache: true };
            const sdExtended = await sd.extend(config);
            const formatted = await sdExtended.formatPlatform(platform, sdOptions);
            const tokens = (await sdExtended.getPlatformTokens(platform, sdOptions)).allTokens;
            const result = {
              permutation,
              formatted,
              tokens
            };
            return Promise.resolve(result);
          })
        );
        processedBuilds[buildName] = results;
      }
    }
  } catch (err) {
    if (err instanceof Error) {
      err.message = err.message.replace('log.verbosity "verbose" or use ', "");
    }
    throw err;
  }
  return processedBuilds;
}

// src/tokens/process/output/declarations.ts
var defaultFileHeader = `build: v${package_default.version}`;
var createTypeDeclarationFiles = (processed$themes) => {
  const colorGroups = buildOptions?.colorGroups || [];
  const customColors = getCustomColors(processed$themes, colorGroups);
  const typeDeclaration = createColorTypeDeclaration([...customColors, "neutral"]);
  return [
    {
      output: `/* This file is deprecated and will be removed in a future release. Use types.d.ts instead */
${typeDeclaration}`,
      destination: "colors.d.ts"
    },
    {
      output: typeDeclaration,
      destination: "types.d.ts"
    }
  ];
};
function createColorTypeDeclaration(colors) {
  console.log(`
\u{1F371} Building ${pc4.green("type declarations")}`);
  const typeDeclaration = `
/* ${defaultFileHeader} */
import type {} from '@digdir/designsystemet/types';

// Augment types based on theme
declare module '@digdir/designsystemet/types' {
  export interface ColorDefinitions {
${colors.map((color) => `    ${color.includes("-") ? `'${color}'` : color}: never;`).join("\n")}
  }
  export interface SeverityColorDefinitions {
    info: never;
    success: never;
    warning: never;
    danger: never;
  }
}
`.trimStart();
  return typeDeclaration;
}

// src/tokens/process/output/tailwind.ts
var createTailwindCSSFiles = (cssFiles) => {
  console.log("\n\u{1F371} Creating Tailwind Config");
  return cssFiles.map((file) => {
    if (file.destination) {
      const tailwindConfig = generateTailwind(file.output);
      const tailwindFile = {
        destination: file.destination.replace(".css", ".tailwind.css"),
        output: tailwindConfig
      };
      return tailwindFile;
    }
    return void 0;
  }).filter((item) => item !== void 0);
};
var generateTailwind = (css) => {
  const tailwind = ["--font-sans: var(--ds-font-family)"];
  const tokens = Array.from(new Set(css.match(/--ds-[^:)]+/g)), (m) => m).sort(
    (a, b) => a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" })
  );
  for (const token of tokens) {
    if (token.startsWith("--ds-color-") && !token.startsWith("--ds-color-focus")) {
      tailwind.push(`--color-${token.replace("--ds-color-", "")}: var(${token})`);
    } else if (token.startsWith("--ds-font-weight-")) {
      tailwind.push(`--font-weight-${token.replace("--ds-font-weight-", "")}: var(${token})`);
    } else if (token.match(/--ds-border-radius-(sm|md|lg|xl)/)) {
      tailwind.push(`--radius-${token.replace("--ds-border-radius-", "")}: var(${token})`);
    } else if (token.match(/--ds-body-(sm|mg|lg)-body-font-size/)) {
      tailwind.push(`--text-${token.replace("--ds-body-", "").replace("-font-size", "")}: var(${token})`);
    } else if (token.match(/^--ds-size-\d+$/)) {
      tailwind.push(`--spacing-${token.replace("--ds-size-", "")}: var(${token})`);
    }
  }
  const dynamicColors = `[data-color] {
      --color-background-default: var(--ds-color-background-default);
      --color-background-tinted: var(--ds-color-background-tinted);
      --color-surface-default: var(--ds-color-surface-default);
      --color-surface-tinted: var(--ds-color-surface-tinted);
      --color-surface-hover: var(--ds-color-surface-hover);
      --color-surface-active: var(--ds-color-surface-active);
      --color-border-subtle: var(--ds-color-border-subtle);
      --color-border-default: var(--ds-color-border-default);
      --color-border-strong: var(--ds-color-border-strong);
      --color-text-subtle: var(--ds-color-text-subtle);
      --color-text-default: var(--ds-color-text-default);
      --color-base-default: var(--ds-color-base-default);
      --color-base-hover: var(--ds-color-base-hover);
      --color-base-active: var(--ds-color-base-active);
      --color-base-contrast-subtle: var(--ds-color-base-contrast-subtle);
      --color-base-contrast-default: var(--ds-color-base-contrast-default);
    }`;
  return `@theme {${tailwind.map((str) => `
  ${str};`).join("")}
}
${dynamicColors}`;
};

// src/tokens/process/output/theme.ts
import pc5 from "picocolors";
import * as R16 from "ramda";
var defaultFileHeader2 = `build: v${package_default.version}`;
var getFileNameWithoutExtension = (path2) => {
  const pathSegments = path2.split("/");
  return pathSegments[pathSegments.length - 1].split(".").slice(0, -1).join(".");
};
var createThemeCSSFiles = ({
  processedBuilds,
  fileHeader = defaultFileHeader2
}) => {
  const groupedByTheme = {};
  for (const [_, buildResults] of Object.entries(processedBuilds)) {
    for (const buildResult of buildResults) {
      const themeName = buildResult.permutation.theme;
      const newOutputs = buildResult.formatted;
      if (R16.isNotEmpty(newOutputs)) {
        const currentOutputs = groupedByTheme[themeName] ?? [];
        groupedByTheme[themeName] = R16.concat(currentOutputs, newOutputs);
      }
    }
  }
  const sortOrder = [
    "size-mode/",
    "type-scale",
    "color-scheme/light",
    "typography/secondary",
    "size",
    "semantic",
    "color-scheme/dark",
    "color-scheme/contrast",
    "typography/primary",
    "color/"
  ];
  const sortByDefinedOrder = R16.sortBy((file) => {
    const filePath = file.destination || "";
    const sortIndex = sortOrder.findIndex((sortElement) => {
      if (sortElement.endsWith("/")) {
        return filePath.includes(sortElement);
      }
      return filePath.includes(`${sortElement}.css`);
    });
    if (sortIndex === -1) {
      console.error(
        pc5.yellow(`WARNING: CSS section does not have a defined sort order: ${filePath.replace(".css", "")}`)
      );
      console.log(
        pc5.dim(
          `
The section will currently be added to the end of the entry file, but the exact
order may change due to nondeterminism.`.trim()
        )
      );
      return Infinity;
    }
    return sortIndex;
  });
  const header = `@charset "UTF-8";
/*
${fileHeader}
*/

`;
  const sortAlphabetically = R16.sort(R16.ascend((x) => x.destination || ""));
  const sortBySize = R16.sortBy(
    R16.pipe((s) => getFileNameWithoutExtension(s.destination ?? ""), sizeComparator)
  );
  const pickOutputs = R16.map(R16.view(R16.lensProp("output")));
  const themeCSSFile = R16.pipe(
    sortAlphabetically,
    sortBySize,
    sortByDefinedOrder,
    pickOutputs,
    R16.join("\n"),
    (content) => header + content
  );
  const themeCSSFiles = Object.entries(groupedByTheme).map(([theme, files]) => ({
    destination: `${theme}.css`,
    output: themeCSSFile(files)
  }));
  return themeCSSFiles;
};

// src/tokens/build.ts
async function write(files, outDir, dry) {
  for (const { destination, output } of files) {
    if (destination) {
      const filePath = path.join(outDir, destination);
      const fileDir = path.dirname(filePath);
      console.log(destination);
      await mkdir(fileDir, dry);
      await writeFile(filePath, output, dry);
    }
  }
}
var buildTokens = async (options) => {
  const outDir = path.resolve(options.outDir);
  const tokensDir = path.resolve(options.tokensDir);
  const $themes = JSON.parse(await readFile(`${tokensDir}/$themes.json`));
  const processed$themes = $themes.map(processThemeObject);
  let $designsystemet;
  try {
    const $designsystemetContent = await readFile(`${tokensDir}/$designsystemet.jsonc`);
    $designsystemet = JSON.parse($designsystemetContent);
  } catch (_error) {
  }
  console.log(`
\u{1F3D7}\uFE0F Start building tokens in ${pc6.green(tokensDir)}`);
  const processedBuilds = await processPlatform({
    ...options,
    outDir,
    tokensDir,
    type: "build",
    processed$themes,
    buildTokenFormats: {}
  });
  const fileHeader = R17.join("")([
    defaultFileHeader2,
    $designsystemet ? `
design-tokens: v${$designsystemet.version}` : ""
  ]);
  let files = [];
  const declarationFiles = createTypeDeclarationFiles(processed$themes);
  const cssFiles = createThemeCSSFiles({ processedBuilds, fileHeader });
  files = [...declarationFiles, ...cssFiles];
  if (options.tailwind) {
    const tailwindFiles = createTailwindCSSFiles(cssFiles);
    files = files.concat(tailwindFiles.filter(Boolean));
  }
  console.log(`
\u{1F4BE} Writing build to ${pc6.green(outDir)}`);
  await write(files, outDir, options.dry);
  console.log(`
\u2705 Finished building tokens!`);
  return processedBuilds;
};
export {
  buildTokens
};
