import type { Tokens } from 'style-dictionary';
import type { DesignToken, TransformedToken } from 'style-dictionary/types';
import { type ColorCategories, type TokenSet } from './types.js';
/**
 * Returns type based on design token format used. Read more:https://v4.styledictionary.com/info/dtcg/
 * @param token Transformed token
 * @returns type
 */
export declare const getType: (token: TransformedToken) => string;
/**
 * Returns value based on design token format used. Read more:https://v4.styledictionary.com/info/dtcg/
 *
 * Use generic (`<T>`) to define return value type
 * @param token Transformed or Design token
 * @returns value
 */
export declare const getValue: <T>(token: TransformedToken | DesignToken) => T;
/**
 * Check if token type matches provided type
 * This function is curried
 * @param types Type or array of types to check against
 * @param token Transformed token
 * @returns boolean
 */
export declare const typeEquals: (types: string[] | string, token: TransformedToken) => boolean;
export declare const pathStartsWithOneOf: ((paths: (string | string[])[], token: TransformedToken) => boolean) & ((paths: (string | string[])[]) => (token: TransformedToken) => boolean);
export declare function isSemanticToken(token: TransformedToken): boolean;
export declare function isSemanticColorToken(token: TransformedToken, color: string): boolean;
export declare function isGlobalColorToken(token: TransformedToken): boolean;
export declare function isColorCategoryToken(token: TransformedToken, category?: ColorCategories): boolean;
export declare const isDigit: (s: string) => boolean;
/** Copied from Style Dictionary and added types
@see https://github.com/amzn/style-dictionary/blob/31c29df0382a61b085f6392dc3225c5009fbffc5/lib/utils/combineJSON.js#L33 */
export declare function traverseObj(obj: Tokens | TokenSet, fn: (obj: TokenSet | Tokens | DesignToken, key: keyof Tokens | string, slice: Tokens | DesignToken | string) => void): import("style-dictionary/types").DesignTokens | TokenSet;
/**
 * In the given tokens array, inline and remove tokens that match the predicate
 *
 * Example: In pseudo-code, given the predicate `(token) => token.path === ['size', '1']` and the following tokens
 * ```js
 *  [
 *    { path: ['size', 'base'], original: { $value: '8px' } },
 *    { path: ['size', '1'], original: { $value: '{size.base} * 2' } },
 *    { path: ['size', 'sm']: original: { $value: 'min({size.1}, 12px)' } }
 *  ]
 * ```
 * would return
 * ```js
 *  [
 *    { path: ['size', 'base'], original: { $value: '8px' } },
 *    { path: ['size', 'sm']: original: { $value: 'min({size.base} * 2, 12px)' } }
 *  ]
 * ```
 *
 * @param shouldInline - predicate to determine if token should be inlined
 * @param tokens - array of tokens to transform
 * @returns copy of `tokens` without those that matched the predicate,
 *          where references to the matching tokens have been inlined
 */
export declare function inlineTokens(shouldInline: (t: TransformedToken) => boolean, tokens: TransformedToken[]): TransformedToken[];
export declare function shortSizeName(size: string): string;
export declare const sizeComparator: (size: string) => number;
export declare function orderBySize(sizes: string[]): string[];
//# sourceMappingURL=utils.d.ts.map