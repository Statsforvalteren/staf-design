// src/tokens/utils.ts
import * as R from "ramda";

// src/tokens/types.ts
var colorCategories = {
  main: "main",
  support: "support"
};

// src/tokens/utils.ts
var mapToLowerCase = R.map(R.toLower);
var hasAnyTruth = R.any(R.equals(true));
var getType = (token) => (token.$type ?? token.type) || "";
var getValue = (token) => token.$value ?? token.value;
var typeEquals = R.curry(
  (types, token) => {
    if (R.isNil(token)) {
      return false;
    }
    return R.includes(R.toLower(getType(token)), R.map(R.toLower, Array.isArray(types) ? types : [types]));
  }
);
var pathStartsWithOneOf = R.curry(
  (paths, token) => {
    if (R.isNil(token)) {
      return false;
    }
    const tokenPath = mapToLowerCase(token.path);
    const matchPathsStartingWith = R.map((pathOrString) => {
      const path = typeof pathOrString === "string" ? [pathOrString] : pathOrString;
      return R.startsWith(mapToLowerCase(path), tokenPath);
    }, paths);
    return hasAnyTruth(matchPathsStartingWith);
  }
);
function isSemanticToken(token) {
  return token.filePath.includes("semantic/");
}
function isSemanticColorToken(token, color) {
  return token.filePath.includes("semantic/") && R.startsWith(["color", color], token.path);
}
function isGlobalColorToken(token) {
  return typeEquals("color", token) && pathStartsWithOneOf(["global"], token);
}
function isColorCategoryToken(token, category) {
  if (!category) {
    return Object.keys(colorCategories).some(
      (colorCategory) => isColorCategoryToken(token, colorCategory)
    );
  }
  return R.startsWith(["color", category], token.path);
}
var isDigit = (s) => /^\d+$/.test(s);
function traverseObj(obj, fn) {
  for (const key in obj) {
    const prop = obj[key];
    if (prop != null) {
      fn.apply(null, [obj, key, prop]);
      if (typeof prop === "object") {
        traverseObj(prop, fn);
      }
    }
  }
  return obj;
}
function inlineTokens(shouldInline, tokens) {
  const [inlineableTokens, otherTokens] = R.partition(shouldInline, tokens);
  return otherTokens.map((token) => {
    let transformed = getValue(token.original);
    for (const ref of inlineableTokens) {
      const refName = ref.path.join(".");
      if (typeof transformed === "string") {
        transformed = transformed.replaceAll(`{${refName}}`, getValue(ref.original));
      }
    }
    const tokenWithInlinedRefs = R.set(R.lensPath(["original", "$value"]), transformed, token);
    return tokenWithInlinedRefs;
  });
}
var sizeMap = {
  xsmall: "xs",
  small: "sm",
  medium: "md",
  large: "lg",
  xlarge: "xl"
};
function shortSizeName(size) {
  return sizeMap[size] ?? size;
}
var sizeComparator = (size) => {
  const sortIndex = Object.entries(sizeMap).findIndex(([key, val]) => key === size || val === size);
  return sortIndex ?? 0;
};
function orderBySize(sizes) {
  return R.sortBy(sizeComparator, sizes);
}
export {
  getType,
  getValue,
  inlineTokens,
  isColorCategoryToken,
  isDigit,
  isGlobalColorToken,
  isSemanticColorToken,
  isSemanticToken,
  orderBySize,
  pathStartsWithOneOf,
  shortSizeName,
  sizeComparator,
  traverseObj,
  typeEquals
};
